<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/cz/osu/main/MainWindow.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/cz/osu/main/MainWindow.java" />
              <option name="originalContent" value="package cz.osu.main;&#10;&#10;import cz.osu.exercises.Cv01_RGB;&#10;import cz.osu.exercises.Matrix2D;&#10;import cz.osu.exercises.Point2D;&#10;import cz.osu.tasks.KU1_TWO;&#10;&#10;import javax.imageio.ImageIO;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.*;&#10;import java.awt.image.BufferedImage;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class MainWindow extends JPanel{&#10;&#10;&#9;private ImagePanel imagePanel;&#10;&#9;private List&lt;RunnableExercise&gt; exercises;&#10;&#9;private List&lt;RunnableExercise&gt; tasks;&#10;&#10;&#9;// Tracking běžících úloh&#10;&#9;private Thread currentExerciseThread;&#10;&#9;private RunnableExercise currentExercise;&#10;&#9;private JLabel statusLabel;&#10;&#10;&#9;// Sdílená instance pro KU2_EXT1 wrapper (kvůli onInterrupt)&#10;&#9;private final Tasks.KU2_EXT1 ku2ext1Wrapper = new Tasks.KU2_EXT1();&#10;&#10;    public MainWindow(){&#10;        exercises = new ArrayList&lt;&gt;();&#10;        tasks = new ArrayList&lt;&gt;();&#10;&#10;        initialize();&#10;        registerExercisesAndTasks();&#10;&#10;        // Spustit default úlohu pokud existuje&#10;        SwingUtilities.invokeLater(this::runDefaultExercise);&#10;    }&#10;&#10;    private void runDefaultExercise() {&#10;        // Hledat default úlohu v exercises&#10;        for (RunnableExercise exercise : exercises) {&#10;            if (exercise.isDefault()) {&#10;                runExercise(exercise);&#10;                return;&#10;            }&#10;        }&#10;&#10;        // Pokud není v exercises, hledat v tasks&#10;        for (RunnableExercise task : tasks) {&#10;            if (task.isDefault()) {&#10;                runExercise(task);&#10;                return;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void initialize(){&#10;&#10;        setLayout(null);&#10;        setFocusable(true);&#10;        requestFocusInWindow();&#10;&#10;        imagePanel = new ImagePanel();&#10;        imagePanel.setBounds(10,60, 970, 600);&#10;        this.add(imagePanel);&#10;&#10;        // Status label pro zobrazení běžící úlohy&#10;        statusLabel = new JLabel(&quot;Žádná úloha neběží&quot;);&#10;        statusLabel.setBounds(290, 10, 400, 30);&#10;        statusLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        statusLabel.setForeground(new Color(60, 60, 60));&#10;        this.add(statusLabel);&#10;&#10;        //open image&#10;        JButton button = new JButton();&#10;        button.setBounds(150,10,120,30);&#10;        button.setText(&quot;Load Image&quot;);&#10;&#10;        button.addActionListener(new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;&#10;                openImage();&#10;            }&#10;        });&#10;        this.add(button);&#10;&#10;        //save image as PNG&#10;        JButton button4 = new JButton();&#10;        button4.setBounds(10,10,120,30);&#10;        button4.setText(&quot;Save as PNG&quot;);&#10;        button4.addActionListener(new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;                saveImageAsPNG();&#10;            }&#10;        });&#10;        this.add(button4);&#10;&#10;        JFrame frame = new JFrame(&quot;Raster Graphics&quot;);&#10;        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        frame.setJMenuBar(createMenuBar());&#10;        frame.getContentPane().add(this);&#10;        frame.setSize(1004, 705);&#10;        frame.setResizable(false);&#10;        frame.setVisible(true);&#10;    }&#10;&#10;    private JMenuBar createMenuBar() {&#10;        JMenuBar menuBar = new JMenuBar();&#10;&#10;        JMenu exercisesMenu = new JMenu(&quot;Exercises&quot;);&#10;        JMenu tasksMenu = new JMenu(&quot;Tasks&quot;);&#10;&#10;        menuBar.add(exercisesMenu);&#10;        menuBar.add(tasksMenu);&#10;&#10;        return menuBar;&#10;    }&#10;&#10;&#9;private void registerExercisesAndTasks() {&#10;&#9;&#9;// Registrace všech exercises&#10;&#9;&#9;addExercise(new Exercises.CV01_RGB());&#10;&#9;&#9;addExercise(new Exercises.CV02_Images());&#10;&#9;&#9;addExercise(new Exercises.CV03_Convolution());&#10;&#9;&#9;addExercise(new Exercises.CV04_Compression());&#10;&#9;&#9;addExercise(new Exercises.CV05_LinesDrawing());&#10;&#9;&#9;addExercise(new Exercises.CV06_Curves());&#10;&#9;&#9;addExercise(new Exercises.CV07_AffineTransformations2D());&#10;&#9;&#9;addExercise(new Exercises.Test01());&#10;&#10;&#9;&#9;// Registrace všech tasks&#10;&#9;&#9;addTask(new Tasks.KU1_ONE());&#10;&#9;&#9;addTask(new Tasks.KU1_TWO());&#10;&#9;&#9;addTask(new Tasks.KU2());&#10;&#9;&#9;addTask(ku2ext1Wrapper); // Použít sdílenou instanci&#10;&#9;&#9;addTask(new Tasks.KU3());&#10;&#9;}&#10;&#10;    private void populateMenu(JMenu menu, List&lt;RunnableExercise&gt; items) {&#10;        menu.removeAll();&#10;&#10;        for (RunnableExercise item : items) {&#10;            JMenuItem menuItem = new JMenuItem(item.getDisplayName());&#10;            menuItem.addActionListener(e -&gt; runExercise(item));&#10;            menu.add(menuItem);&#10;        }&#10;&#10;        if (items.isEmpty()) {&#10;            JMenuItem emptyItem = new JMenuItem(&quot;(žádné úlohy)&quot;);&#10;            emptyItem.setEnabled(false);&#10;            menu.add(emptyItem);&#10;        }&#10;    }&#10;&#10;    private void runExercise(RunnableExercise exercise) {&#10;        // Ukončit předchozí úlohu pokud běží&#10;        stopCurrentExercise();&#10;&#10;        // Aktualizovat status&#10;        statusLabel.setText(&quot;Běží: &quot; + exercise.getDisplayName());&#10;        statusLabel.setForeground(new Color(0, 128, 0));&#10;&#10;        // Spustit novou úlohu v samostatném vlákně&#10;        currentExercise = exercise;&#10;        currentExerciseThread = new Thread(() -&gt; {&#10;            try {&#10;                exercise.execute(this);&#10;            } catch (Exception e) {&#10;                if (!(e instanceof InterruptedException)) {&#10;                    e.printStackTrace();&#10;                    SwingUtilities.invokeLater(() -&gt; {&#10;                        JOptionPane.showMessageDialog(this,&#10;                            &quot;Chyba při běhu úlohy: &quot; + e.getMessage(),&#10;                            &quot;Chyba&quot;,&#10;                            JOptionPane.ERROR_MESSAGE);&#10;                    });&#10;                }&#10;            } finally {&#10;                SwingUtilities.invokeLater(() -&gt; {&#10;                    if (currentExercise == exercise) {&#10;                        statusLabel.setText(&quot;Dokončeno: &quot; + exercise.getDisplayName());&#10;                        statusLabel.setForeground(new Color(60, 60, 60));&#10;                        currentExercise = null;&#10;                        currentExerciseThread = null;&#10;                    }&#10;                });&#10;            }&#10;        });&#10;        currentExerciseThread.start();&#10;    }&#10;&#10;    private void stopCurrentExercise() {&#10;        if (currentExerciseThread != null &amp;&amp; currentExerciseThread.isAlive()) {&#10;            System.out.println(&quot;Ukončuji předchozí úlohu: &quot; + currentExercise.getDisplayName());&#10;&#10;            // Zavolat onInterrupt callback&#10;            if (currentExercise != null) {&#10;                currentExercise.onInterrupt();&#10;            }&#10;&#10;            // Přerušit thread&#10;            currentExerciseThread.interrupt();&#10;&#10;            try {&#10;                // Počkat max 500ms na ukončení&#10;                currentExerciseThread.join(500);&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;&#10;            currentExercise = null;&#10;            currentExerciseThread = null;&#10;        }&#10;    }&#10;&#10;    public void addExercise(RunnableExercise exercise) {&#10;        exercises.add(exercise);&#10;        updateMenus();&#10;    }&#10;&#10;    public void addTask(RunnableExercise task) {&#10;        tasks.add(task);&#10;        updateMenus();&#10;    }&#10;&#10;    private void updateMenus() {&#10;        JMenuBar menuBar = ((JFrame) SwingUtilities.getWindowAncestor(this)).getJMenuBar();&#10;        if (menuBar != null &amp;&amp; menuBar.getMenuCount() &gt;= 2) {&#10;            populateMenu(menuBar.getMenu(0), exercises);&#10;            populateMenu(menuBar.getMenu(1), tasks);&#10;        }&#10;    }&#10;&#10;    private void openImage(){&#10;&#10;        String userDir = System.getProperty(&quot;user.home&quot;);&#10;        JFileChooser fc = new JFileChooser(userDir +&quot;/Documents/.OSU/3s ZS/&quot;);&#10;        fc.setDialogTitle(&quot;Load Image&quot;);&#10;&#10;        if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {&#10;&#10;            File file = fc.getSelectedFile();&#10;&#10;            try {&#10;&#10;                BufferedImage temp = ImageIO.read(file);&#10;&#10;                if(temp != null){&#10;                    //TODO THIS IS THE ENTRY POINT&#10;&#10;                    imagePanel.setImage(temp);&#10;&#10;                }else {&#10;&#10;                    JOptionPane.showMessageDialog(null, &quot;Unable to load image&quot;, &quot;Open image: &quot;, JOptionPane.ERROR_MESSAGE);&#10;                }&#10;&#10;            }catch (IOException e){&#10;&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Thread-safe metoda pro načtení obrázku jako V_RAM&#10;     * Lze volat z exercise threadu&#10;     */&#10;    public V_RAM loadImageAsVRAM(){&#10;        BufferedImage image = loadImage();&#10;        if (image != null) {&#10;            showImage(image);&#10;        }&#10;        return convertBufferedToVRAM(image);&#10;    }&#10;&#10;    /**&#10;     * Thread-safe metoda pro načtení obrázku&#10;     * Lze volat z exercise threadu&#10;     */&#10;    public BufferedImage loadImage(){&#10;        if (SwingUtilities.isEventDispatchThread()) {&#10;            return loadImageInternal();&#10;        } else {&#10;            final BufferedImage[] result = new BufferedImage[1];&#10;            try {&#10;                SwingUtilities.invokeAndWait(() -&gt; result[0] = loadImageInternal());&#10;            } catch (Exception e) {&#10;                e.printStackTrace();&#10;            }&#10;            return result[0];&#10;        }&#10;    }&#10;&#10;    private BufferedImage loadImageInternal(){&#10;        String userDir = System.getProperty(&quot;user.home&quot;);&#10;        JFileChooser fc = new JFileChooser(userDir +&quot;/Documents/.OSU/3s ZS/GALP&quot;);&#10;        fc.setDialogTitle(&quot;Load Image&quot;);&#10;&#10;        if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {&#10;            File file = fc.getSelectedFile();&#10;&#10;            try {&#10;                return ImageIO.read(file);&#10;            }catch (IOException e){&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private V_RAM convertBufferedToVRAM(BufferedImage image){&#10;        if (image==null) return new V_RAM(0,0);&#10;&#10;        V_RAM vRam = new V_RAM(image.getWidth(), image.getHeight());&#10;        //System.out.println(); //debug&#10;        for (int y = 0; y &lt; vRam.getHeight(); y++) {&#10;            for (int x = 0; x &lt; vRam.getWidth(); x++) {&#10;                vRam.setPixelsInt(x, y, image.getRGB(x, y));&#10;                //int[] rgb = vRam.getPixelRGB(x, y); //2 lines debug code prints values of image&#10;                //System.out.print(&quot; | &quot; + rgb[1] + &quot;:&quot; + rgb[2] + &quot;:&quot; + rgb[3]);&#10;            }&#10;            //System.out.print(&quot; |\n&quot;); //debug&#10;        }&#10;        //System.out.println(); //debug&#10;        return vRam;&#10;    }&#10;&#10;    public void showImage(BufferedImage bufferedImage){&#10;        if(bufferedImage != null){&#10;&#10;            imagePanel.setImage(bufferedImage);&#10;&#10;        }else {&#10;&#10;            JOptionPane.showMessageDialog(null, &quot;Unable to load image&quot;, &quot;Open image: &quot;, JOptionPane.ERROR_MESSAGE);&#10;        }&#10;    }&#10;&#10;    private void saveImageAsPNG(){&#10;&#10;        String userDir = System.getProperty(&quot;user.home&quot;);&#10;        JFileChooser fc = new JFileChooser(userDir +&quot;/Desktop&quot;);&#10;        fc.setDialogTitle(&quot;Save Image as PNG&quot;);&#10;&#10;        if (fc.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {&#10;&#10;            File file = fc.getSelectedFile();&#10;&#10;            String fname = file.getAbsolutePath();&#10;&#10;            if(!fname.endsWith(&quot;.png&quot;) ) file = new File(fname + &quot;.png&quot;);&#10;&#10;            try {&#10;&#10;                ImageIO.write(imagePanel.getImage(), &quot;png&quot;, file);&#10;&#10;            } catch (IOException e) {&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;    }&#10;&#10;    private static void delay(long millis){&#10;        if (millis &lt; 0) {&#10;            System.out.println(&quot;Cannot wait for negative or 0 time.&quot;);&#10;            return;&#10;        }&#10;        if (millis == 0) return;&#10;        try {&#10;            Thread.sleep(millis);&#10;        } catch (InterruptedException e){&#10;            System.out.println(&quot;Thread interrupted.&quot;);&#10;            Thread.currentThread().interrupt();&#10;            throw new RuntimeException(e);  // Propagovat přerušení&#10;        }&#10;    }&#10;&#10;    private static void delaySeconds(double seconds){&#10;        delay((long)(seconds * 1000d));&#10;    }&#10;&#10;    private static void confirm(){&#10;&#10;    }&#10;&#10;    public ImagePanel getImagePanel() {&#10;        return imagePanel;&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            MainWindow window = new MainWindow();&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package cz.osu.main;&#10;&#10;import cz.osu.exercises.Cv01_RGB;&#10;import cz.osu.exercises.Matrix2D;&#10;import cz.osu.exercises.Point2D;&#10;import cz.osu.tasks.KU1_TWO;&#10;&#10;import javax.imageio.ImageIO;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.*;&#10;import java.awt.image.BufferedImage;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class MainWindow extends JPanel{&#10;&#10;&#9;private ImagePanel imagePanel;&#10;&#9;private List&lt;RunnableExercise&gt; exercises;&#10;&#9;private List&lt;RunnableExercise&gt; tasks;&#10;&#10;&#9;// Tracking běžících úloh&#10;&#9;private Thread currentExerciseThread;&#10;&#9;private RunnableExercise currentExercise;&#10;&#9;private JLabel statusLabel;&#10;&#10;&#9;// Sdílená instance pro KU2_EXT1 wrapper (kvůli onInterrupt)&#10;&#9;private final Tasks.KU2_EXT1 ku2ext1Wrapper = new Tasks.KU2_EXT1();&#10;&#10;    public MainWindow(){&#10;        exercises = new ArrayList&lt;&gt;();&#10;        tasks = new ArrayList&lt;&gt;();&#10;&#10;        initialize();&#10;        registerExercisesAndTasks();&#10;&#10;        // Spustit default úlohu pokud existuje&#10;        SwingUtilities.invokeLater(this::runDefaultExercise);&#10;    }&#10;&#10;    private void runDefaultExercise() {&#10;        // Hledat default úlohu v exercises&#10;        for (RunnableExercise exercise : exercises) {&#10;            if (exercise.isDefault()) {&#10;                runExercise(exercise);&#10;                return;&#10;            }&#10;        }&#10;&#10;        // Pokud není v exercises, hledat v tasks&#10;        for (RunnableExercise task : tasks) {&#10;            if (task.isDefault()) {&#10;                runExercise(task);&#10;                return;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void initialize(){&#10;&#10;        setLayout(null);&#10;        setFocusable(true);&#10;        requestFocusInWindow();&#10;&#10;        imagePanel = new ImagePanel();&#10;        imagePanel.setBounds(10,60, 970, 600);&#10;        this.add(imagePanel);&#10;&#10;        // Status label pro zobrazení běžící úlohy&#10;        statusLabel = new JLabel(&quot;Žádná úloha neběží&quot;);&#10;        statusLabel.setBounds(290, 10, 400, 30);&#10;        statusLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        statusLabel.setForeground(new Color(60, 60, 60));&#10;        this.add(statusLabel);&#10;&#10;        //open image&#10;        JButton button = new JButton();&#10;        button.setBounds(150,10,120,30);&#10;        button.setText(&quot;Load Image&quot;);&#10;&#10;        button.addActionListener(new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;&#10;                openImage();&#10;            }&#10;        });&#10;        this.add(button);&#10;&#10;        //save image as PNG&#10;        JButton button4 = new JButton();&#10;        button4.setBounds(10,10,120,30);&#10;        button4.setText(&quot;Save as PNG&quot;);&#10;        button4.addActionListener(new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;                saveImageAsPNG();&#10;            }&#10;        });&#10;        this.add(button4);&#10;&#10;        JFrame frame = new JFrame(&quot;Raster Graphics&quot;);&#10;        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        frame.setJMenuBar(createMenuBar());&#10;        frame.getContentPane().add(this);&#10;        frame.setSize(1004, 705);&#10;        frame.setResizable(false);&#10;        frame.setVisible(true);&#10;    }&#10;&#10;    private JMenuBar createMenuBar() {&#10;        JMenuBar menuBar = new JMenuBar();&#10;&#10;        JMenu exercisesMenu = new JMenu(&quot;Exercises&quot;);&#10;        JMenu tasksMenu = new JMenu(&quot;Tasks&quot;);&#10;&#10;        menuBar.add(exercisesMenu);&#10;        menuBar.add(tasksMenu);&#10;&#10;        return menuBar;&#10;    }&#10;&#10;&#9;private void registerExercisesAndTasks() {&#10;&#9;&#9;// Registrace všech exercises&#10;&#9;&#9;addExercise(new Exercises.CV01_RGB());&#10;&#9;&#9;addExercise(new Exercises.CV02_Images());&#10;&#9;&#9;addExercise(new Exercises.CV03_Convolution());&#10;&#9;&#9;addExercise(new Exercises.CV04_Compression());&#10;&#9;&#9;addExercise(new Exercises.CV05_LinesDrawing());&#10;&#9;&#9;addExercise(new Exercises.CV06_Curves());&#10;&#9;&#9;addExercise(new Exercises.CV07_AffineTransformations2D());&#10;&#9;&#9;addExercise(new Exercises.Test01());&#10;&#10;&#9;&#9;// Registrace všech tasks&#10;&#9;&#9;addTask(new Tasks.KU1_ONE());&#10;&#9;&#9;addTask(new Tasks.KU1_TWO());&#10;&#9;&#9;addTask(new Tasks.KU2());&#10;&#9;&#9;addTask(ku2ext1Wrapper); // Použít sdílenou instanci&#10;&#9;&#9;addTask(new Tasks.KU3());&#10;&#9;}&#10;&#10;    private void populateMenu(JMenu menu, List&lt;RunnableExercise&gt; items) {&#10;        menu.removeAll();&#10;&#10;        for (RunnableExercise item : items) {&#10;            JMenuItem menuItem = new JMenuItem(item.getDisplayName());&#10;            menuItem.addActionListener(e -&gt; runExercise(item));&#10;            menu.add(menuItem);&#10;        }&#10;&#10;        if (items.isEmpty()) {&#10;            JMenuItem emptyItem = new JMenuItem(&quot;(žádné úlohy)&quot;);&#10;            emptyItem.setEnabled(false);&#10;            menu.add(emptyItem);&#10;        }&#10;    }&#10;&#10;    private void runExercise(RunnableExercise exercise) {&#10;        // Ukončit předchozí úlohu pokud běží&#10;        stopCurrentExercise();&#10;&#10;        // Aktualizovat status&#10;        statusLabel.setText(&quot;Běží: &quot; + exercise.getDisplayName());&#10;        statusLabel.setForeground(new Color(0, 128, 0));&#10;&#10;        // Spustit novou úlohu v samostatném vlákně&#10;        currentExercise = exercise;&#10;        currentExerciseThread = new Thread(() -&gt; {&#10;            try {&#10;                exercise.execute(this);&#10;            } catch (Exception e) {&#10;                if (!(e instanceof InterruptedException)) {&#10;                    e.printStackTrace();&#10;                    SwingUtilities.invokeLater(() -&gt; {&#10;                        JOptionPane.showMessageDialog(this,&#10;                            &quot;Chyba při běhu úlohy: &quot; + e.getMessage(),&#10;                            &quot;Chyba&quot;,&#10;                            JOptionPane.ERROR_MESSAGE);&#10;                    });&#10;                }&#10;            } finally {&#10;                SwingUtilities.invokeLater(() -&gt; {&#10;                    if (currentExercise == exercise) {&#10;                        statusLabel.setText(&quot;Dokončeno: &quot; + exercise.getDisplayName());&#10;                        statusLabel.setForeground(new Color(60, 60, 60));&#10;                        currentExercise = null;&#10;                        currentExerciseThread = null;&#10;                    }&#10;                });&#10;            }&#10;        });&#10;        currentExerciseThread.start();&#10;    }&#10;&#10;    private void stopCurrentExercise() {&#10;        if (currentExerciseThread != null &amp;&amp; currentExerciseThread.isAlive()) {&#10;            System.out.println(&quot;MainWindow.stopCurrentExercise() - Ukončuji předchozí úlohu: &quot; + currentExercise.getDisplayName());&#10;            System.out.println(&quot;MainWindow.stopCurrentExercise() - currentExercise instance = &quot; + currentExercise);&#10;&#10;            // Zavolat onInterrupt callback&#10;            if (currentExercise != null) {&#10;                System.out.println(&quot;MainWindow.stopCurrentExercise() - volám currentExercise.onInterrupt()&quot;);&#10;                currentExercise.onInterrupt();&#10;            }&#10;&#10;            // Přerušit thread&#10;            currentExerciseThread.interrupt();&#10;&#10;            try {&#10;                // Počkat max 500ms na ukončení&#10;                currentExerciseThread.join(500);&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;&#10;            currentExercise = null;&#10;            currentExerciseThread = null;&#10;        } else {&#10;            System.out.println(&quot;MainWindow.stopCurrentExercise() - žádná úloha neběží nebo není alive&quot;);&#10;        }&#10;    }&#10;&#10;    public void addExercise(RunnableExercise exercise) {&#10;        exercises.add(exercise);&#10;        updateMenus();&#10;    }&#10;&#10;    public void addTask(RunnableExercise task) {&#10;        tasks.add(task);&#10;        updateMenus();&#10;    }&#10;&#10;    private void updateMenus() {&#10;        JMenuBar menuBar = ((JFrame) SwingUtilities.getWindowAncestor(this)).getJMenuBar();&#10;        if (menuBar != null &amp;&amp; menuBar.getMenuCount() &gt;= 2) {&#10;            populateMenu(menuBar.getMenu(0), exercises);&#10;            populateMenu(menuBar.getMenu(1), tasks);&#10;        }&#10;    }&#10;&#10;    private void openImage(){&#10;&#10;        String userDir = System.getProperty(&quot;user.home&quot;);&#10;        JFileChooser fc = new JFileChooser(userDir +&quot;/Documents/.OSU/3s ZS/&quot;);&#10;        fc.setDialogTitle(&quot;Load Image&quot;);&#10;&#10;        if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {&#10;&#10;            File file = fc.getSelectedFile();&#10;&#10;            try {&#10;&#10;                BufferedImage temp = ImageIO.read(file);&#10;&#10;                if(temp != null){&#10;                    //TODO THIS IS THE ENTRY POINT&#10;&#10;                    imagePanel.setImage(temp);&#10;&#10;                }else {&#10;&#10;                    JOptionPane.showMessageDialog(null, &quot;Unable to load image&quot;, &quot;Open image: &quot;, JOptionPane.ERROR_MESSAGE);&#10;                }&#10;&#10;            }catch (IOException e){&#10;&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Thread-safe metoda pro načtení obrázku jako V_RAM&#10;     * Lze volat z exercise threadu&#10;     */&#10;    public V_RAM loadImageAsVRAM(){&#10;        BufferedImage image = loadImage();&#10;        if (image != null) {&#10;            showImage(image);&#10;        }&#10;        return convertBufferedToVRAM(image);&#10;    }&#10;&#10;    /**&#10;     * Thread-safe metoda pro načtení obrázku&#10;     * Lze volat z exercise threadu&#10;     */&#10;    public BufferedImage loadImage(){&#10;        if (SwingUtilities.isEventDispatchThread()) {&#10;            return loadImageInternal();&#10;        } else {&#10;            final BufferedImage[] result = new BufferedImage[1];&#10;            try {&#10;                SwingUtilities.invokeAndWait(() -&gt; result[0] = loadImageInternal());&#10;            } catch (Exception e) {&#10;                e.printStackTrace();&#10;            }&#10;            return result[0];&#10;        }&#10;    }&#10;&#10;    private BufferedImage loadImageInternal(){&#10;        String userDir = System.getProperty(&quot;user.home&quot;);&#10;        JFileChooser fc = new JFileChooser(userDir +&quot;/Documents/.OSU/3s ZS/GALP&quot;);&#10;        fc.setDialogTitle(&quot;Load Image&quot;);&#10;&#10;        if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {&#10;            File file = fc.getSelectedFile();&#10;&#10;            try {&#10;                return ImageIO.read(file);&#10;            }catch (IOException e){&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private V_RAM convertBufferedToVRAM(BufferedImage image){&#10;        if (image==null) return new V_RAM(0,0);&#10;&#10;        V_RAM vRam = new V_RAM(image.getWidth(), image.getHeight());&#10;        //System.out.println(); //debug&#10;        for (int y = 0; y &lt; vRam.getHeight(); y++) {&#10;            for (int x = 0; x &lt; vRam.getWidth(); x++) {&#10;                vRam.setPixelsInt(x, y, image.getRGB(x, y));&#10;                //int[] rgb = vRam.getPixelRGB(x, y); //2 lines debug code prints values of image&#10;                //System.out.print(&quot; | &quot; + rgb[1] + &quot;:&quot; + rgb[2] + &quot;:&quot; + rgb[3]);&#10;            }&#10;            //System.out.print(&quot; |\n&quot;); //debug&#10;        }&#10;        //System.out.println(); //debug&#10;        return vRam;&#10;    }&#10;&#10;    public void showImage(BufferedImage bufferedImage){&#10;        if(bufferedImage != null){&#10;&#10;            imagePanel.setImage(bufferedImage);&#10;&#10;        }else {&#10;&#10;            JOptionPane.showMessageDialog(null, &quot;Unable to load image&quot;, &quot;Open image: &quot;, JOptionPane.ERROR_MESSAGE);&#10;        }&#10;    }&#10;&#10;    private void saveImageAsPNG(){&#10;&#10;        String userDir = System.getProperty(&quot;user.home&quot;);&#10;        JFileChooser fc = new JFileChooser(userDir +&quot;/Desktop&quot;);&#10;        fc.setDialogTitle(&quot;Save Image as PNG&quot;);&#10;&#10;        if (fc.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {&#10;&#10;            File file = fc.getSelectedFile();&#10;&#10;            String fname = file.getAbsolutePath();&#10;&#10;            if(!fname.endsWith(&quot;.png&quot;) ) file = new File(fname + &quot;.png&quot;);&#10;&#10;            try {&#10;&#10;                ImageIO.write(imagePanel.getImage(), &quot;png&quot;, file);&#10;&#10;            } catch (IOException e) {&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;    }&#10;&#10;    private static void delay(long millis){&#10;        if (millis &lt; 0) {&#10;            System.out.println(&quot;Cannot wait for negative or 0 time.&quot;);&#10;            return;&#10;        }&#10;        if (millis == 0) return;&#10;        try {&#10;            Thread.sleep(millis);&#10;        } catch (InterruptedException e){&#10;            System.out.println(&quot;Thread interrupted.&quot;);&#10;            Thread.currentThread().interrupt();&#10;            throw new RuntimeException(e);  // Propagovat přerušení&#10;        }&#10;    }&#10;&#10;    private static void delaySeconds(double seconds){&#10;        delay((long)(seconds * 1000d));&#10;    }&#10;&#10;    private static void confirm(){&#10;&#10;    }&#10;&#10;    public ImagePanel getImagePanel() {&#10;        return imagePanel;&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            MainWindow window = new MainWindow();&#10;        });&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/cz/osu/main/Tasks.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/cz/osu/main/Tasks.java" />
              <option name="originalContent" value="package cz.osu.main;&#10;&#10;import cz.osu.tasks.KU1_TWO;&#10;&#10;/**&#10; * Registry všech tasks - každý jako inner class&#10; */&#10;public class Tasks {&#10;&#10;    /**&#10;     * KU1_ONE - Odstranění červených očí&#10;     */&#10;    public static class KU1_ONE implements RunnableExercise {&#10;        @Override&#10;        public String getDisplayName() {&#10;            return &quot;KU1_ONE - Odstranění červených očí&quot;;&#10;        }&#10;&#10;        @Override&#10;        public void execute(MainWindow mainWindow) {&#10;            cz.osu.tasks.KU1_ONE KU1ONE = new cz.osu.tasks.KU1_ONE(mainWindow);&#10;            KU1ONE.run();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * KU1_TWO - Kontextové zpracování šedotónového obrazu&#10;     */&#10;    public static class KU1_TWO implements RunnableExercise {&#10;        @Override&#10;        public String getDisplayName() {&#10;            return &quot;KU1_TWO - Kontextové zpracování šedotónového obrazu&quot;;&#10;        }&#10;&#10;        @Override&#10;        public void execute(MainWindow mainWindow) {&#10;            cz.osu.tasks.KU1_TWO KU1TWO = new cz.osu.tasks.KU1_TWO(mainWindow);&#10;            KU1TWO.run();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * KU2 - Kreslení spline pomocí kubických Bézierových křivek&#10;     */&#10;    public static class KU2 implements RunnableExercise {&#10;        @Override&#10;        public String getDisplayName() {&#10;            return &quot;KU2 - Kreslení spline (kubické Bézierovy křivky)&quot;;&#10;        }&#10;&#10;        @Override&#10;        public void execute(MainWindow mainWindow) {&#10;            cz.osu.tasks.KU2 ku2 = new cz.osu.tasks.KU2(mainWindow);&#10;            ku2.run();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * KU2_EXT1 - Písmenový font pomocí Bézierových křivek&#10;     */&#10;    public static class KU2_EXT1 implements RunnableExercise {&#10;        @Override&#10;        public String getDisplayName() {&#10;            return &quot;KU2_EXT1 - Písmenový font (Bézierovy křivky)&quot;;&#10;        }&#10;&#10;        @Override&#10;        public void execute(MainWindow mainWindow) {&#10;            cz.osu.tasks.KU2_EXT1 ku2ext1 = new cz.osu.tasks.KU2_EXT1(mainWindow);&#10;            ku2ext1.run();&#10;        }&#10;&#10;        @Override&#10;        public boolean isDefault() {&#10;            return true;  // Tato úloha se spustí automaticky při startu&#10;        }&#10;    }&#10;&#10;    /**&#10;     * KU3 - TODO: Zatím neimplementováno&#10;     */&#10;    public static class KU3 implements RunnableExercise {&#10;        @Override&#10;        public String getDisplayName() {&#10;            return &quot;KU3 (TODO)&quot;;&#10;        }&#10;&#10;        @Override&#10;        public void execute(MainWindow mainWindow) {&#10;            System.out.println(&quot;KU3 zatím není implementováno&quot;);&#10;            // TODO: Implementace KU3&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package cz.osu.main;&#10;&#10;/**&#10; * Registry všech tasks - každý jako inner class&#10; */&#10;public class Tasks {&#10;&#10;    /**&#10;     * KU1_ONE - Odstranění červených očí&#10;     */&#10;    public static class KU1_ONE implements RunnableExercise {&#10;        @Override&#10;        public String getDisplayName() {&#10;            return &quot;KU1_ONE - Odstranění červených očí&quot;;&#10;        }&#10;&#10;        @Override&#10;        public void execute(MainWindow mainWindow) {&#10;            cz.osu.tasks.KU1_ONE KU1ONE = new cz.osu.tasks.KU1_ONE(mainWindow);&#10;            KU1ONE.run();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * KU1_TWO - Kontextové zpracování šedotónového obrazu&#10;     */&#10;    public static class KU1_TWO implements RunnableExercise {&#10;        @Override&#10;        public String getDisplayName() {&#10;            return &quot;KU1_TWO - Kontextové zpracování šedotónového obrazu&quot;;&#10;        }&#10;&#10;        @Override&#10;        public void execute(MainWindow mainWindow) {&#10;            cz.osu.tasks.KU1_TWO KU1TWO = new cz.osu.tasks.KU1_TWO(mainWindow);&#10;            KU1TWO.run();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * KU2 - Kreslení spline pomocí kubických Bézierových křivek&#10;     */&#10;    public static class KU2 implements RunnableExercise {&#10;        @Override&#10;        public String getDisplayName() {&#10;            return &quot;KU2 - Kreslení spline (kubické Bézierovy křivky)&quot;;&#10;        }&#10;&#10;        @Override&#10;        public void execute(MainWindow mainWindow) {&#10;            cz.osu.tasks.KU2 ku2 = new cz.osu.tasks.KU2(mainWindow);&#10;            ku2.run();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * KU2_EXT1 - Písmenový font pomocí Bézierových křivek&#10;     */&#10;    public static class KU2_EXT1 implements RunnableExercise {&#10;        private cz.osu.tasks.KU2_EXT1 currentInstance;&#10;&#10;        @Override&#10;        public String getDisplayName() {&#10;            return &quot;KU2_EXT1 - Písmenový font (Bézierovy křivky)&quot;;&#10;        }&#10;&#10;        @Override&#10;        public void execute(MainWindow mainWindow) {&#10;            System.out.println(&quot;Tasks.KU2_EXT1.execute() - this wrapper instance = &quot; + this);&#10;            currentInstance = new cz.osu.tasks.KU2_EXT1(mainWindow);&#10;            System.out.println(&quot;Tasks.KU2_EXT1.execute() - created task instance = &quot; + currentInstance);&#10;            currentInstance.run();&#10;        }&#10;&#10;&#9;&#9;@Override&#10;&#9;&#9;public void onInterrupt() {&#10;&#9;&#9;&#9;System.out.println(&quot;Tasks.KU2_EXT1.onInterrupt() - this wrapper instance = &quot; + this);&#10;&#9;&#9;&#9;System.out.println(&quot;Tasks.KU2_EXT1.onInterrupt() - currentInstance = &quot; + currentInstance);&#10;&#9;&#9;&#9;if (currentInstance != null) {&#10;&#9;&#9;&#9;&#9;currentInstance.dispose();&#10;&#9;&#9;&#9;&#9;currentInstance = null;&#10;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;System.out.println(&quot;Tasks.KU2_EXT1.onInterrupt() - currentInstance je NULL!&quot;);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;        @Override&#10;        public boolean isDefault() {&#10;            return true;  // Tato úloha se spustí automaticky při startu&#10;        }&#10;    }&#10;&#10;    /**&#10;     * KU3 - TODO: Zatím neimplementováno&#10;     */&#10;    public static class KU3 implements RunnableExercise {&#10;        @Override&#10;        public String getDisplayName() {&#10;            return &quot;KU3 (TODO)&quot;;&#10;        }&#10;&#10;        @Override&#10;        public void execute(MainWindow mainWindow) {&#10;            System.out.println(&quot;KU3 zatím není implementováno&quot;);&#10;            // TODO: Implementace KU3&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/cz/osu/tasks/KU2_EXT1.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/cz/osu/tasks/KU2_EXT1.java" />
              <option name="originalContent" value="package cz.osu.tasks;&#10;&#10;import cz.osu.exercises.Cv05_LinesDrawing;&#10;import cz.osu.main.MainWindow;&#10;import cz.osu.main.V_RAM;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.*;&#10;import java.io.*;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * KU2_EXT1 - Editor písmenového fontu pomocí Bézierových křivek&#10; *&#10; * Interaktivní editor pro tvorbu písmen pomocí kubických Bézierových křivek.&#10; * Umožňuje úpravu kontrolních bodů a vodítek (handles) myší a ukládání/načítání z JSON.&#10; */&#10;public class KU2_EXT1 {&#10;&#9;private final MainWindow mainWindow;&#10;&#9;private List&lt;CurvePoint&gt; controlPoints;&#10;&#9;private CurvePoint selectedPoint = null;&#10;&#9;private int selectedIndex = -1;&#10;&#9;private HandleType selectedHandle = HandleType.NONE;&#10;&#9;private static final int POINT_RADIUS = 6;&#10;&#9;private static final int HANDLE_RADIUS = 4;&#10;&#9;private static final String SAVE_FILE = &quot;letter_S_points.json&quot;;&#10;&#9;private static final int CANVAS_WIDTH = 600;&#10;&#9;private static final int CANVAS_HEIGHT = 600;&#10;&#9;private boolean showHandles = true;&#10;&#9;private JFrame editorFrame; // Reference na editor okno pro možnost zavření&#10;&#10;&#9;enum HandleType {&#10;&#9;&#9;NONE, MAIN, LEFT_HANDLE, RIGHT_HANDLE, BOTH_HANDLES&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Bod s vodítky pro Bézierovu křivku&#10;&#9; */&#10;&#9;class CurvePoint {&#10;&#9;&#9;Point main;        // Hlavní bod&#10;&#9;&#9;Point leftHandle;  // Levé vodítko (L)&#10;&#9;&#9;Point rightHandle; // Pravé vodítko (R)&#10;&#10;&#9;&#9;CurvePoint(int x, int y) {&#10;&#9;&#9;&#9;this.main = new Point(x, y);&#10;&#9;&#9;&#9;// Výchozí vodítka - automaticky vypočítaná&#10;&#9;&#9;&#9;this.leftHandle = new Point(x - 40, y);&#10;&#9;&#9;&#9;this.rightHandle = new Point(x + 40, y);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;CurvePoint(Point main, Point leftHandle, Point rightHandle) {&#10;&#9;&#9;&#9;this.main = main;&#10;&#9;&#9;&#9;this.leftHandle = leftHandle;&#10;&#9;&#9;&#9;this.rightHandle = rightHandle;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/**&#10;&#9;&#9; * Resetování handleru na výchozí pozici&#10;&#9;&#9; */&#10;&#9;&#9;void resetHandles() {&#10;&#9;&#9;&#9;this.leftHandle = new Point(main.x - 40, main.y);&#10;&#9;&#9;&#9;this.rightHandle = new Point(main.x + 40, main.y);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Automatický výpočet vodítek na základě sousedních bodů&#10;&#9;&#9;void autoCalculateHandles(CurvePoint prev, CurvePoint next) {&#10;&#9;&#9;&#9;if (prev == null || next == null) return;&#10;&#10;&#9;&#9;&#9;double dx = (next.main.x - prev.main.x) / 6.0;&#10;&#9;&#9;&#9;double dy = (next.main.y - prev.main.y) / 6.0;&#10;&#10;&#9;&#9;&#9;leftHandle = new Point(&#10;&#9;&#9;&#9;&#9;(int) Math.round(main.x - dx),&#10;&#9;&#9;&#9;&#9;(int) Math.round(main.y - dy)&#10;&#9;&#9;&#9;);&#10;&#9;&#9;&#9;rightHandle = new Point(&#10;&#9;&#9;&#9;&#9;(int) Math.round(main.x + dx),&#10;&#9;&#9;&#9;&#9;(int) Math.round(main.y + dy)&#10;&#9;&#9;&#9;);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;public KU2_EXT1(MainWindow mainWindow) {&#10;&#9;&#9;this.mainWindow = mainWindow;&#10;&#9;&#9;this.controlPoints = new ArrayList&lt;&gt;();&#10;&#9;&#9;loadPoints();&#10;&#9;}&#10;&#10;&#9;public void run() {&#10;&#9;&#9;// Pokud nejsou body, vytvoř výchozí&#10;&#9;&#9;if (controlPoints.isEmpty()) {&#10;&#9;&#9;&#9;createDefaultSPoints();&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Vytvoř editor okno&#10;&#9;&#9;createEditorWindow();&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Vytvoření výchozích bodů pro písmeno S&#10;&#9; */&#10;&#9;private void createDefaultSPoints() {&#10;&#9;&#9;// Vytvoř body s pozicemi&#10;&#9;&#9;controlPoints.add(new CurvePoint(180, 80));&#10;&#10;&#9;&#9;// Automaticky vypočítej vodítka&#10;&#9;&#9;recalculateAllHandles();&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Přepočítání všech vodítek automaticky&#10;&#9; */&#10;&#9;private void recalculateAllHandles() {&#10;&#9;&#9;int n = controlPoints.size();&#10;&#9;&#9;if (n &lt; 2) return; // Potřebujeme alespoň 2 body&#10;&#10;&#9;&#9;if (n == 2) {&#10;&#9;&#9;&#9;// Pro 2 body vypočítej jednoduché vodítka&#10;&#9;&#9;&#9;CurvePoint p0 = controlPoints.get(0);&#10;&#9;&#9;&#9;CurvePoint p1 = controlPoints.get(1);&#10;&#10;&#9;&#9;&#9;double dx = (p1.main.x - p0.main.x) / 3.0;&#10;&#9;&#9;&#9;double dy = (p1.main.y - p0.main.y) / 3.0;&#10;&#10;&#9;&#9;&#9;p0.rightHandle = new Point(&#10;&#9;&#9;&#9;&#9;(int) Math.round(p0.main.x + dx),&#10;&#9;&#9;&#9;&#9;(int) Math.round(p0.main.y + dy)&#10;&#9;&#9;&#9;);&#10;&#9;&#9;&#9;p0.leftHandle = new Point(&#10;&#9;&#9;&#9;&#9;(int) Math.round(p0.main.x - dx),&#10;&#9;&#9;&#9;&#9;(int) Math.round(p0.main.y - dy)&#10;&#9;&#9;&#9;);&#10;&#10;&#9;&#9;&#9;p1.leftHandle = new Point(&#10;&#9;&#9;&#9;&#9;(int) Math.round(p1.main.x - dx),&#10;&#9;&#9;&#9;&#9;(int) Math.round(p1.main.y - dy)&#10;&#9;&#9;&#9;);&#10;&#9;&#9;&#9;p1.rightHandle = new Point(&#10;&#9;&#9;&#9;&#9;(int) Math.round(p1.main.x + dx),&#10;&#9;&#9;&#9;&#9;(int) Math.round(p1.main.y + dy)&#10;&#9;&#9;&#9;);&#10;&#9;&#9;&#9;return;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Pro 3+ bodů použij fantomové body&#10;&#9;&#9;List&lt;CurvePoint&gt; extended = new ArrayList&lt;&gt;();&#10;&#9;&#9;extended.add(controlPoints.get(0)); // Fantom na začátku&#10;&#9;&#9;extended.addAll(controlPoints);&#10;&#9;&#9;extended.add(controlPoints.get(n - 1)); // Fantom na konci&#10;&#10;&#9;&#9;// Vypočítej vodítka pro každý bod&#10;&#9;&#9;for (int i = 1; i &lt;= n; i++) {&#10;&#9;&#9;&#9;CurvePoint prev = extended.get(i - 1);&#10;&#9;&#9;&#9;CurvePoint curr = extended.get(i);&#10;&#9;&#9;&#9;CurvePoint next = extended.get(i + 1);&#10;&#10;&#9;&#9;&#9;curr.autoCalculateHandles(prev, next);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Načtení bodů z JSON souboru&#10;&#9; */&#10;&#9;private void loadPoints() {&#10;&#9;&#9;File file = new File(SAVE_FILE);&#10;&#9;&#9;if (!file.exists()) {&#10;&#9;&#9;&#9;return;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;try (BufferedReader reader = new BufferedReader(new FileReader(file))) {&#10;&#9;&#9;&#9;StringBuilder json = new StringBuilder();&#10;&#9;&#9;&#9;String line;&#10;&#9;&#9;&#9;while ((line = reader.readLine()) != null) {&#10;&#9;&#9;&#9;&#9;json.append(line.trim());&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;String content = json.toString();&#10;&#10;&#9;&#9;&#9;// Najdi začátek pole points&#10;&#9;&#9;&#9;int pointsStart = content.indexOf(&quot;[&quot;);&#10;&#9;&#9;&#9;int pointsEnd = content.lastIndexOf(&quot;]&quot;);&#10;&#10;&#9;&#9;&#9;if (pointsStart == -1 || pointsEnd == -1) {&#10;&#9;&#9;&#9;&#9;throw new Exception(&quot;Neplatný formát JSON&quot;);&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;String pointsArray = content.substring(pointsStart + 1, pointsEnd);&#10;&#9;&#9;&#9;controlPoints.clear();&#10;&#10;&#9;&#9;&#9;// Parsování jednotlivých objektů&#10;&#9;&#9;&#9;int depth = 0;&#10;&#9;&#9;&#9;StringBuilder currentObject = new StringBuilder();&#10;&#10;&#9;&#9;&#9;for (int i = 0; i &lt; pointsArray.length(); i++) {&#10;&#9;&#9;&#9;&#9;char c = pointsArray.charAt(i);&#10;&#10;&#9;&#9;&#9;&#9;if (c == '{') {&#10;&#9;&#9;&#9;&#9;&#9;depth++;&#10;&#9;&#9;&#9;&#9;&#9;currentObject.setLength(0);&#10;&#9;&#9;&#9;&#9;} else if (c == '}') {&#10;&#9;&#9;&#9;&#9;&#9;depth--;&#10;&#9;&#9;&#9;&#9;&#9;if (depth == 0 &amp;&amp; currentObject.length() &gt; 0) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;// Parsuj tento objekt&#10;&#9;&#9;&#9;&#9;&#9;&#9;parsePointObject(currentObject.toString());&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;} else if (depth &gt; 0) {&#10;&#9;&#9;&#9;&#9;&#9;currentObject.append(c);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;System.out.println(&quot;Načteno &quot; + controlPoints.size() + &quot; bodů z &quot; + SAVE_FILE);&#10;&#10;&#9;&#9;&#9;// Pokud body nemají vodítka, vypočítej je&#10;&#9;&#9;&#9;if (!controlPoints.isEmpty() &amp;&amp; controlPoints.get(0).leftHandle == null) {&#10;&#9;&#9;&#9;&#9;recalculateAllHandles();&#10;&#9;&#9;&#9;}&#10;&#9;&#9;} catch (Exception e) {&#10;&#9;&#9;&#9;System.out.println(&quot;Chyba při načítání: &quot; + e.getMessage());&#10;&#9;&#9;&#9;e.printStackTrace();&#10;&#9;&#9;&#9;controlPoints.clear();&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Parsování jednoho bodu z JSON objektu&#10;&#9; */&#10;&#9;private void parsePointObject(String objStr) {&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;Integer x = null, y = null;&#10;&#9;&#9;&#9;Integer lx = null, ly = null, rx = null, ry = null;&#10;&#10;&#9;&#9;&#9;// Rozděl na páry klíč:hodnota&#10;&#9;&#9;&#9;String[] pairs = objStr.split(&quot;,&quot;);&#10;&#10;&#9;&#9;&#9;for (String pair : pairs) {&#10;&#9;&#9;&#9;&#9;String[] kv = pair.split(&quot;:&quot;);&#10;&#9;&#9;&#9;&#9;if (kv.length != 2) continue;&#10;&#10;&#9;&#9;&#9;&#9;String key = kv[0].trim().replace(&quot;\&quot;&quot;, &quot;&quot;);&#10;&#9;&#9;&#9;&#9;String value = kv[1].trim();&#10;&#10;&#9;&#9;&#9;&#9;switch (key) {&#10;&#9;&#9;&#9;&#9;&#9;case &quot;x&quot;: x = Integer.parseInt(value); break;&#10;&#9;&#9;&#9;&#9;&#9;case &quot;y&quot;: y = Integer.parseInt(value); break;&#10;&#9;&#9;&#9;&#9;&#9;case &quot;lx&quot;: lx = Integer.parseInt(value); break;&#10;&#9;&#9;&#9;&#9;&#9;case &quot;ly&quot;: ly = Integer.parseInt(value); break;&#10;&#9;&#9;&#9;&#9;&#9;case &quot;rx&quot;: rx = Integer.parseInt(value); break;&#10;&#9;&#9;&#9;&#9;&#9;case &quot;ry&quot;: ry = Integer.parseInt(value); break;&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;if (x != null &amp;&amp; y != null) {&#10;&#9;&#9;&#9;&#9;if (lx != null &amp;&amp; ly != null &amp;&amp; rx != null &amp;&amp; ry != null) {&#10;&#9;&#9;&#9;&#9;&#9;// S vodítky&#10;&#9;&#9;&#9;&#9;&#9;controlPoints.add(new CurvePoint(&#10;&#9;&#9;&#9;&#9;&#9;&#9;new Point(x, y),&#10;&#9;&#9;&#9;&#9;&#9;&#9;new Point(lx, ly),&#10;&#9;&#9;&#9;&#9;&#9;&#9;new Point(rx, ry)&#10;&#9;&#9;&#9;&#9;&#9;));&#10;&#9;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;&#9;// Bez vodítek&#10;&#9;&#9;&#9;&#9;&#9;controlPoints.add(new CurvePoint(x, y));&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;} catch (Exception e) {&#10;&#9;&#9;&#9;System.out.println(&quot;Chyba při parsování bodu: &quot; + e.getMessage());&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Uložení bodů do JSON souboru&#10;&#9; */&#10;&#9;private void savePoints() {&#10;&#9;&#9;try (PrintWriter writer = new PrintWriter(new FileWriter(SAVE_FILE))) {&#10;&#9;&#9;&#9;writer.println(&quot;{&quot;);&#10;&#9;&#9;&#9;writer.println(&quot;  \&quot;points\&quot;: [&quot;);&#10;&#10;&#9;&#9;&#9;for (int i = 0; i &lt; controlPoints.size(); i++) {&#10;&#9;&#9;&#9;&#9;CurvePoint p = controlPoints.get(i);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;    {&quot;);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;\&quot;x\&quot;: &quot; + p.main.x + &quot;, &quot;);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;\&quot;y\&quot;: &quot; + p.main.y + &quot;, &quot;);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;\&quot;lx\&quot;: &quot; + p.leftHandle.x + &quot;, &quot;);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;\&quot;ly\&quot;: &quot; + p.leftHandle.y + &quot;, &quot;);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;\&quot;rx\&quot;: &quot; + p.rightHandle.x + &quot;, &quot;);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;\&quot;ry\&quot;: &quot; + p.rightHandle.y);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;}&quot;);&#10;&#10;&#9;&#9;&#9;&#9;if (i &lt; controlPoints.size() - 1) {&#10;&#9;&#9;&#9;&#9;&#9;writer.println(&quot;,&quot;);&#10;&#9;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;&#9;writer.println();&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;writer.println(&quot;  ]&quot;);&#10;&#9;&#9;&#9;writer.println(&quot;}&quot;);&#10;&#10;&#9;&#9;&#9;System.out.println(&quot;Uloženo &quot; + controlPoints.size() + &quot; bodů do &quot; + SAVE_FILE);&#10;&#9;&#9;} catch (IOException e) {&#10;&#9;&#9;&#9;System.out.println(&quot;Chyba při ukládání: &quot; + e.getMessage());&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Vytvoření okna editoru&#10;&#9; */&#10;&#9;private void createEditorWindow() {&#10;&#9;&#9;editorFrame = new JFrame(&quot;Editor písmene S - Bézierovy křivky (Ctrl+klik = oba handlers)&quot;);&#10;&#9;&#9;editorFrame.setSize(700, 800);&#10;&#9;&#9;editorFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);&#10;&#9;&#9;editorFrame.setResizable(true); // Povolení změny velikosti&#10;&#10;&#9;&#9;// Panel pro kreslení s ohraničením&#10;&#9;&#9;JPanel drawPanel = new JPanel() {&#10;&#9;&#9;&#9;@Override&#10;&#9;&#9;&#9;public Dimension getPreferredSize() {&#10;&#9;&#9;&#9;&#9;return new Dimension(CANVAS_WIDTH + 100, CANVAS_HEIGHT + 100);&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;@Override&#10;&#9;&#9;&#9;protected void paintComponent(Graphics g) {&#10;&#9;&#9;&#9;&#9;super.paintComponent(g);&#10;&#9;&#9;&#9;&#9;Graphics2D g2d = (Graphics2D) g;&#10;&#9;&#9;&#9;&#9;g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;&#10;&#9;&#9;&#9;&#9;// Vyčištění pozadí (světle šedé)&#10;&#9;&#9;&#9;&#9;g2d.setColor(new Color(240, 240, 240));&#10;&#9;&#9;&#9;&#9;g2d.fillRect(0, 0, getWidth(), getHeight());&#10;&#10;&#9;&#9;&#9;&#9;// Vykreslení plátna (bílé)&#10;&#9;&#9;&#9;&#9;int offsetX = (getWidth() - CANVAS_WIDTH) / 2;&#10;&#9;&#9;&#9;&#9;int offsetY = (getHeight() - CANVAS_HEIGHT) / 2;&#10;&#9;&#9;&#9;&#9;g2d.setColor(Color.WHITE);&#10;&#9;&#9;&#9;&#9;g2d.fillRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);&#10;&#10;&#9;&#9;&#9;&#9;// Ohraničení plátna&#10;&#9;&#9;&#9;&#9;g2d.setColor(Color.BLACK);&#10;&#9;&#9;&#9;&#9;g2d.setStroke(new BasicStroke(2));&#10;&#9;&#9;&#9;&#9;g2d.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);&#10;&#10;&#9;&#9;&#9;&#9;// Translace pro vycentrování&#10;&#9;&#9;&#9;&#9;g2d.translate(offsetX, offsetY);&#10;&#10;&#9;&#9;&#9;&#9;if (controlPoints.size() &gt;= 2) {&#10;&#9;&#9;&#9;&#9;&#9;// Vykreslení spline&#10;&#9;&#9;&#9;&#9;&#9;drawSplineOnGraphics(g2d, controlPoints, Color.BLACK);&#10;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;// Vykreslení vodítek a kontrolních bodů&#10;&#9;&#9;&#9;&#9;for (int i = 0; i &lt; controlPoints.size(); i++) {&#10;&#9;&#9;&#9;&#9;&#9;CurvePoint p = controlPoints.get(i);&#10;&#10;&#9;&#9;&#9;&#9;&#9;if (showHandles) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;// Vodítka - čáry&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.setColor(new Color(150, 150, 255));&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.setStroke(new BasicStroke(1));&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.drawLine(p.main.x, p.main.y, p.leftHandle.x, p.leftHandle.y);&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.drawLine(p.main.x, p.main.y, p.rightHandle.x, p.rightHandle.y);&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// Levé vodítko&#10;&#9;&#9;&#9;&#9;&#9;&#9;boolean isSelectedLeft = (i == selectedIndex &amp;&amp; selectedHandle == HandleType.LEFT_HANDLE);&#10;&#9;&#9;&#9;&#9;&#9;&#9;boolean isBothSelected = (i == selectedIndex &amp;&amp; selectedHandle == HandleType.BOTH_HANDLES);&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.setColor((isSelectedLeft || isBothSelected) ? Color.RED : new Color(100, 100, 255));&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.fillOval(p.leftHandle.x - HANDLE_RADIUS, p.leftHandle.y - HANDLE_RADIUS,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;HANDLE_RADIUS * 2, HANDLE_RADIUS * 2);&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// Pravé vodítko&#10;&#9;&#9;&#9;&#9;&#9;&#9;boolean isSelectedRight = (i == selectedIndex &amp;&amp; selectedHandle == HandleType.RIGHT_HANDLE);&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.setColor((isSelectedRight || isBothSelected) ? Color.RED : new Color(100, 100, 255));&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.fillOval(p.rightHandle.x - HANDLE_RADIUS, p.rightHandle.y - HANDLE_RADIUS,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;HANDLE_RADIUS * 2, HANDLE_RADIUS * 2);&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;// Spojnice mezi hlavními body&#10;&#9;&#9;&#9;&#9;&#9;if (i &gt; 0) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.setColor(new Color(200, 200, 200));&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{2}, 0));&#10;&#9;&#9;&#9;&#9;&#9;&#9;CurvePoint prev = controlPoints.get(i - 1);&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.drawLine(prev.main.x, prev.main.y, p.main.x, p.main.y);&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;// Hlavní bod&#10;&#9;&#9;&#9;&#9;&#9;boolean isSelectedMain = (i == selectedIndex &amp;&amp;&#10;&#9;&#9;&#9;&#9;&#9;&#9;(selectedHandle == HandleType.MAIN || selectedHandle == HandleType.BOTH_HANDLES));&#10;&#9;&#9;&#9;&#9;&#9;g2d.setColor(isSelectedMain ? Color.RED : Color.BLUE);&#10;&#9;&#9;&#9;&#9;&#9;g2d.fillOval(p.main.x - POINT_RADIUS, p.main.y - POINT_RADIUS,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;POINT_RADIUS * 2, POINT_RADIUS * 2);&#10;&#10;&#9;&#9;&#9;&#9;&#9;// Číslo bodu&#10;&#9;&#9;&#9;&#9;&#9;g2d.setColor(Color.BLACK);&#10;&#9;&#9;&#9;&#9;&#9;g2d.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 10));&#10;&#9;&#9;&#9;&#9;&#9;g2d.drawString(String.valueOf(i), p.main.x + POINT_RADIUS + 2, p.main.y - POINT_RADIUS);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;};&#10;&#10;&#9;&#9;drawPanel.setBackground(Color.WHITE);&#10;&#10;&#9;&#9;// Mouse listener pro editaci bodů&#10;&#9;&#9;MouseAdapter mouseAdapter = new MouseAdapter() {&#10;&#9;&#9;&#9;private int getOffsetX() {&#10;&#9;&#9;&#9;&#9;return (drawPanel.getWidth() - CANVAS_WIDTH) / 2;&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;private int getOffsetY() {&#10;&#9;&#9;&#9;&#9;return (drawPanel.getHeight() - CANVAS_HEIGHT) / 2;&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;private int toCanvasX(int mouseX) {&#10;&#9;&#9;&#9;&#9;return mouseX - getOffsetX();&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;private int toCanvasY(int mouseY) {&#10;&#9;&#9;&#9;&#9;return mouseY - getOffsetY();&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;@Override&#10;&#9;&#9;&#9;public void mousePressed(MouseEvent e) {&#10;&#9;&#9;&#9;&#9;int canvasX = toCanvasX(e.getX());&#10;&#9;&#9;&#9;&#9;int canvasY = toCanvasY(e.getY());&#10;&#9;&#9;&#9;&#9;boolean ctrlPressed = e.isControlDown();&#10;&#10;&#9;&#9;&#9;&#9;// Nejprve hledej vodítka, pak hlavní body&#10;&#9;&#9;&#9;&#9;for (int i = 0; i &lt; controlPoints.size(); i++) {&#10;&#9;&#9;&#9;&#9;&#9;CurvePoint p = controlPoints.get(i);&#10;&#10;&#9;&#9;&#9;&#9;&#9;if (showHandles) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;// Levé vodítko&#10;&#9;&#9;&#9;&#9;&#9;&#9;if (isNear(canvasX, canvasY, p.leftHandle.x, p.leftHandle.y, HANDLE_RADIUS)) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint = p;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedIndex = i;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedHandle = HandleType.LEFT_HANDLE;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;return;&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// Pravé vodítko&#10;&#9;&#9;&#9;&#9;&#9;&#9;if (isNear(canvasX, canvasY, p.rightHandle.x, p.rightHandle.y, HANDLE_RADIUS)) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint = p;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedIndex = i;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedHandle = HandleType.RIGHT_HANDLE;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;return;&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;// Hlavní bod - s Ctrl = oba handlers, bez Ctrl = jen bod&#10;&#9;&#9;&#9;&#9;&#9;if (isNear(canvasX, canvasY, p.main.x, p.main.y, POINT_RADIUS)) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint = p;&#10;&#9;&#9;&#9;&#9;&#9;&#9;selectedIndex = i;&#10;&#9;&#9;&#9;&#9;&#9;&#9;selectedHandle = ctrlPressed ? HandleType.BOTH_HANDLES : HandleType.MAIN;&#10;&#9;&#9;&#9;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;&#9;&#9;&#9;return;&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;selectedPoint = null;&#10;&#9;&#9;&#9;&#9;selectedIndex = -1;&#10;&#9;&#9;&#9;&#9;selectedHandle = HandleType.NONE;&#10;&#9;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;@Override&#10;&#9;&#9;&#9;public void mouseDragged(MouseEvent e) {&#10;&#9;&#9;&#9;&#9;if (selectedPoint != null) {&#10;&#9;&#9;&#9;&#9;&#9;int canvasX = toCanvasX(e.getX());&#10;&#9;&#9;&#9;&#9;&#9;int canvasY = toCanvasY(e.getY());&#10;&#9;&#9;&#9;&#9;&#9;int clampedX = clamp(canvasX, 0, CANVAS_WIDTH - 1);&#10;&#9;&#9;&#9;&#9;&#9;int clampedY = clamp(canvasY, 0, CANVAS_HEIGHT - 1);&#10;&#10;&#9;&#9;&#9;&#9;&#9;switch (selectedHandle) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;case MAIN:&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Posuň hlavní bod i vodítka&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int dx = clampedX - selectedPoint.main.x;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int dy = clampedY - selectedPoint.main.y;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.main.x = clampedX;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.main.y = clampedY;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.leftHandle.x = clamp(selectedPoint.leftHandle.x + dx, 0, CANVAS_WIDTH - 1);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.leftHandle.y = clamp(selectedPoint.leftHandle.y + dy, 0, CANVAS_HEIGHT - 1);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.rightHandle.x = clamp(selectedPoint.rightHandle.x + dx, 0, CANVAS_WIDTH - 1);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.rightHandle.y = clamp(selectedPoint.rightHandle.y + dy, 0, CANVAS_HEIGHT - 1);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;&#9;&#9;case LEFT_HANDLE:&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.leftHandle.x = clampedX;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.leftHandle.y = clampedY;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;&#9;&#9;case RIGHT_HANDLE:&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.rightHandle.x = clampedX;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.rightHandle.y = clampedY;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;&#9;&#9;case BOTH_HANDLES:&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Symetrický pohyb obou handlers - myš ovládá směr&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int deltaX = clampedX - selectedPoint.main.x;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int deltaY = clampedY - selectedPoint.main.y;&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Pravý handle jde tam, kam je myš&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.rightHandle.x = clampedX;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.rightHandle.y = clampedY;&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Levý handle jde na opačnou stranu symetricky&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.leftHandle.x = clamp(selectedPoint.main.x - deltaX, 0, CANVAS_WIDTH - 1);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.leftHandle.y = clamp(selectedPoint.main.y - deltaY, 0, CANVAS_HEIGHT - 1);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;@Override&#10;&#9;&#9;&#9;public void mouseReleased(MouseEvent e) {&#10;&#9;&#9;&#9;&#9;if (selectedPoint != null) {&#10;&#9;&#9;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;private boolean isNear(int x1, int y1, int x2, int y2, int radius) {&#10;&#9;&#9;&#9;&#9;return Math.abs(x1 - x2) &lt;= radius &amp;&amp; Math.abs(y1 - y2) &lt;= radius;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;};&#10;&#10;&#9;&#9;drawPanel.addMouseListener(mouseAdapter);&#10;&#9;&#9;drawPanel.addMouseMotionListener(mouseAdapter);&#10;&#10;&#9;&#9;// Panel s tlačítky&#10;&#9;&#9;JPanel buttonPanel = new JPanel();&#10;&#9;&#9;buttonPanel.setLayout(new GridLayout(3, 2, 5, 5));&#10;&#10;&#9;&#9;JButton saveButton = new JButton(&quot;Uložit&quot;);&#10;&#9;&#9;saveButton.addActionListener(e -&gt; {&#10;&#9;&#9;&#9;savePoints();&#10;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;});&#10;&#10;&#9;&#9;JButton loadButton = new JButton(&quot;Načíst&quot;);&#10;&#9;&#9;loadButton.addActionListener(e -&gt; {&#10;&#9;&#9;&#9;loadPoints();&#10;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;});&#10;&#10;&#9;&#9;JButton addButton = new JButton(&quot;Přidat bod&quot;);&#10;&#9;&#9;addButton.addActionListener(e -&gt; {&#10;&#9;&#9;&#9;// Přidat nový bod bez přepočítávání existujících handlers&#10;&#9;&#9;&#9;controlPoints.add(new CurvePoint(150, 150));&#10;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;});&#10;&#10;&#9;&#9;JButton removeButton = new JButton(&quot;Odebrat bod&quot;);&#10;&#9;&#9;removeButton.addActionListener(e -&gt; {&#10;&#9;&#9;&#9;if (selectedIndex &gt;= 0 &amp;&amp; selectedIndex &lt; controlPoints.size()) {&#10;&#9;&#9;&#9;&#9;controlPoints.remove(selectedIndex);&#10;&#9;&#9;&#9;&#9;selectedIndex = -1;&#10;&#9;&#9;&#9;&#9;selectedPoint = null;&#10;&#9;&#9;&#9;&#9;selectedHandle = HandleType.NONE;&#10;&#9;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;&#9;}&#10;&#9;&#9;});&#10;&#10;&#9;&#9;JButton resetButton = new JButton(&quot;Reset&quot;);&#10;&#9;&#9;resetButton.addActionListener(e -&gt; {&#10;&#9;&#9;&#9;controlPoints.clear();&#10;&#9;&#9;&#9;createDefaultSPoints();&#10;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;});&#10;&#10;&#9;&#9;JButton toggleHandlesButton = new JButton(&quot;Vodítka: ZAP&quot;);&#10;&#9;&#9;toggleHandlesButton.addActionListener(e -&gt; {&#10;&#9;&#9;&#9;showHandles = !showHandles;&#10;&#9;&#9;&#9;toggleHandlesButton.setText(&quot;Vodítka: &quot; + (showHandles ? &quot;ZAP&quot; : &quot;VYP&quot;));&#10;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;});&#10;&#10;&#9;&#9;JButton resetHandlesButton = new JButton(&quot;Reset vodítka&quot;);&#10;&#9;&#9;resetHandlesButton.addActionListener(e -&gt; {&#10;&#9;&#9;&#9;if (selectedIndex &gt;= 0 &amp;&amp; selectedIndex &lt; controlPoints.size()) {&#10;&#9;&#9;&#9;&#9;controlPoints.get(selectedIndex).resetHandles();&#10;&#9;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;JOptionPane.showMessageDialog(editorFrame,&#10;&#9;&#9;&#9;&#9;&#9;&quot;Nejdřív vyberte bod kliknutím na něj.&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&quot;Info&quot;,&#10;&#9;&#9;&#9;&#9;&#9;JOptionPane.INFORMATION_MESSAGE);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;});&#10;&#10;&#9;&#9;buttonPanel.add(saveButton);&#10;&#9;&#9;buttonPanel.add(loadButton);&#10;&#9;&#9;buttonPanel.add(addButton);&#10;&#9;&#9;buttonPanel.add(removeButton);&#10;&#9;&#9;buttonPanel.add(resetButton);&#10;&#9;&#9;buttonPanel.add(toggleHandlesButton);&#10;&#9;&#9;buttonPanel.add(resetHandlesButton);&#10;&#10;&#9;&#9;// Sestavení okna&#10;&#9;&#9;editorFrame.setLayout(new BorderLayout());&#10;&#9;&#9;editorFrame.add(drawPanel, BorderLayout.CENTER);&#10;&#9;&#9;editorFrame.add(buttonPanel, BorderLayout.SOUTH);&#10;&#10;&#9;&#9;editorFrame.setVisible(true);&#10;&#10;&#9;&#9;// Počáteční vykreslení&#10;&#9;&#9;updateMainWindow();&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Aktualizace hlavního okna s výsledným písmem&#10;&#9; */&#10;&#9;private void updateMainWindow() {&#10;&#9;&#9;V_RAM vRam = new V_RAM(CANVAS_WIDTH, CANVAS_HEIGHT);&#10;&#9;&#9;clearBackground(vRam, Color.WHITE);&#10;&#10;&#9;&#9;if (controlPoints.size() &gt;= 2) {&#10;&#9;&#9;&#9;drawSplineVRAM(vRam, controlPoints, Color.BLACK, 2);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;mainWindow.showImage(vRam.getImage());&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Vykreslení spline na Graphics2D (pro editor)&#10;&#9; */&#10;&#9;private void drawSplineOnGraphics(Graphics2D g2d, List&lt;CurvePoint&gt; points, Color color) {&#10;&#9;&#9;int n = points.size();&#10;&#9;&#9;if (n &lt; 2) return;&#10;&#10;&#9;&#9;g2d.setColor(color);&#10;&#9;&#9;g2d.setStroke(new BasicStroke(2));&#10;&#10;&#9;&#9;// Definice a vykreslení segmentů&#10;&#9;&#9;double step = 0.01;&#10;&#10;&#9;&#9;for (int i = 0; i &lt; n - 1; i++) {&#10;&#9;&#9;&#9;CurvePoint p0 = points.get(i);&#10;&#9;&#9;&#9;CurvePoint p1 = points.get(i + 1);&#10;&#10;&#9;&#9;&#9;// 4 kontrolní body pro kubickou Bézierovu křivku&#10;&#9;&#9;&#9;Point cp0 = p0.main;           // Začátek&#10;&#9;&#9;&#9;Point cp1 = p0.rightHandle;    // Pravé vodítko prvního bodu&#10;&#9;&#9;&#9;Point cp2 = p1.leftHandle;     // Levé vodítko druhého bodu&#10;&#9;&#9;&#9;Point cp3 = p1.main;           // Konec&#10;&#10;&#9;&#9;&#9;// Pre-kalkulace koeficientů&#10;&#9;&#9;&#9;double qx0 = cp0.x;&#10;&#9;&#9;&#9;double qy0 = cp0.y;&#10;&#9;&#9;&#9;double qx1 = 3 * (cp1.x - cp0.x);&#10;&#9;&#9;&#9;double qy1 = 3 * (cp1.y - cp0.y);&#10;&#9;&#9;&#9;double qx2 = 3 * (cp0.x - 2 * cp1.x + cp2.x);&#10;&#9;&#9;&#9;double qy2 = 3 * (cp0.y - 2 * cp1.y + cp2.y);&#10;&#9;&#9;&#9;double qx3 = cp3.x - 3 * cp2.x + 3 * cp1.x - cp0.x;&#10;&#9;&#9;&#9;double qy3 = cp3.y - 3 * cp2.y + 3 * cp1.y - cp0.y;&#10;&#10;&#9;&#9;&#9;Point prevPoint = null;&#10;&#10;&#9;&#9;&#9;for (double t = 0.0; t &lt;= 1.0; t += step) {&#10;&#9;&#9;&#9;&#9;double t2 = t * t;&#10;&#9;&#9;&#9;&#9;double t3 = t2 * t;&#10;&#10;&#9;&#9;&#9;&#9;double x = qx0 + qx1 * t + qx2 * t2 + qx3 * t3;&#10;&#9;&#9;&#9;&#9;double y = qy0 + qy1 * t + qy2 * t2 + qy3 * t3;&#10;&#10;&#9;&#9;&#9;&#9;Point currentPoint = new Point((int) Math.round(x), (int) Math.round(y));&#10;&#10;&#9;&#9;&#9;&#9;if (prevPoint != null) {&#10;&#9;&#9;&#9;&#9;&#9;g2d.drawLine(prevPoint.x, prevPoint.y, currentPoint.x, currentPoint.y);&#10;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;prevPoint = currentPoint;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Vykreslení spline do V_RAM&#10;&#9; */&#10;&#9;private void drawSplineVRAM(V_RAM vRam, List&lt;CurvePoint&gt; points, Color color, int thickness) {&#10;&#9;&#9;int n = points.size();&#10;&#9;&#9;if (n &lt; 2) return;&#10;&#10;&#9;&#9;int width = vRam.getWidth();&#10;&#9;&#9;int height = vRam.getHeight();&#10;&#10;&#9;&#9;// Definice a vykreslení segmentů&#10;&#9;&#9;double step = 0.005;&#10;&#10;&#9;&#9;for (int i = 0; i &lt; n - 1; i++) {&#10;&#9;&#9;&#9;CurvePoint p0 = points.get(i);&#10;&#9;&#9;&#9;CurvePoint p1 = points.get(i + 1);&#10;&#10;&#9;&#9;&#9;// 4 kontrolní body&#10;&#9;&#9;&#9;Point cp0 = p0.main;&#10;&#9;&#9;&#9;Point cp1 = p0.rightHandle;&#10;&#9;&#9;&#9;Point cp2 = p1.leftHandle;&#10;&#9;&#9;&#9;Point cp3 = p1.main;&#10;&#10;&#9;&#9;&#9;// Pre-kalkulace koeficientů&#10;&#9;&#9;&#9;double qx0 = cp0.x;&#10;&#9;&#9;&#9;double qy0 = cp0.y;&#10;&#9;&#9;&#9;double qx1 = 3 * (cp1.x - cp0.x);&#10;&#9;&#9;&#9;double qy1 = 3 * (cp1.y - cp0.y);&#10;&#9;&#9;&#9;double qx2 = 3 * (cp0.x - 2 * cp1.x + cp2.x);&#10;&#9;&#9;&#9;double qy2 = 3 * (cp0.y - 2 * cp1.y + cp2.y);&#10;&#9;&#9;&#9;double qx3 = cp3.x - 3 * cp2.x + 3 * cp1.x - cp0.x;&#10;&#9;&#9;&#9;double qy3 = cp3.y - 3 * cp2.y + 3 * cp1.y - cp0.y;&#10;&#10;&#9;&#9;&#9;Point prevPoint = null;&#10;&#10;&#9;&#9;&#9;for (double t = 0.0; t &lt;= 1.0; t += step) {&#10;&#9;&#9;&#9;&#9;double t2 = t * t;&#10;&#9;&#9;&#9;&#9;double t3 = t2 * t;&#10;&#10;&#9;&#9;&#9;&#9;double x = qx0 + qx1 * t + qx2 * t2 + qx3 * t3;&#10;&#9;&#9;&#9;&#9;double y = qy0 + qy1 * t + qy2 * t2 + qy3 * t3;&#10;&#10;&#9;&#9;&#9;&#9;// Bounds checking&#10;&#9;&#9;&#9;&#9;int px = (int) Math.round(x);&#10;&#9;&#9;&#9;&#9;int py = (int) Math.round(y);&#10;&#9;&#9;&#9;&#9;if (px &lt; 0 || px &gt;= width || py &lt; 0 || py &gt;= height) {&#10;&#9;&#9;&#9;&#9;&#9;prevPoint = null; // Přeskoč kreslení mimo hranice&#10;&#9;&#9;&#9;&#9;&#9;continue;&#10;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;Point currentPoint = new Point(px, py);&#10;&#10;&#9;&#9;&#9;&#9;if (prevPoint != null) {&#10;&#9;&#9;&#9;&#9;&#9;drawThickLine(vRam, prevPoint.x, prevPoint.y, currentPoint.x, currentPoint.y, color, thickness);&#10;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;prevPoint = currentPoint;&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;// Závěrečný segment&#10;&#9;&#9;&#9;int fx = (int) Math.round(qx0 + qx1 + qx2 + qx3);&#10;&#9;&#9;&#9;int fy = (int) Math.round(qy0 + qy1 + qy2 + qy3);&#10;&#10;&#9;&#9;&#9;if (fx &gt;= 0 &amp;&amp; fx &lt; width &amp;&amp; fy &gt;= 0 &amp;&amp; fy &lt; height) {&#10;&#9;&#9;&#9;&#9;Point finalPoint = new Point(fx, fy);&#10;&#9;&#9;&#9;&#9;if (prevPoint != null) {&#10;&#9;&#9;&#9;&#9;&#9;drawThickLine(vRam, prevPoint.x, prevPoint.y, finalPoint.x, finalPoint.y, color, thickness);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Kreslení tlustší čáry&#10;&#9; */&#10;&#9;private void drawThickLine(V_RAM vRam, int x1, int y1, int x2, int y2, Color color, int thickness) {&#10;&#9;&#9;int width = vRam.getWidth();&#10;&#9;&#9;int height = vRam.getHeight();&#10;&#10;&#9;&#9;for (int dy = -thickness/2; dy &lt;= thickness/2; dy++) {&#10;&#9;&#9;&#9;for (int dx = -thickness/2; dx &lt;= thickness/2; dx++) {&#10;&#9;&#9;&#9;&#9;int nx1 = x1 + dx;&#10;&#9;&#9;&#9;&#9;int ny1 = y1 + dy;&#10;&#9;&#9;&#9;&#9;int nx2 = x2 + dx;&#10;&#9;&#9;&#9;&#9;int ny2 = y2 + dy;&#10;&#10;&#9;&#9;&#9;&#9;// Bounds checking - kreslí jen pokud jsou OBA body v rozsahu&#10;&#9;&#9;&#9;&#9;if (nx1 &gt;= 0 &amp;&amp; nx1 &lt; width &amp;&amp; ny1 &gt;= 0 &amp;&amp; ny1 &lt; height &amp;&amp;&#10;&#9;&#9;&#9;&#9;&#9;nx2 &gt;= 0 &amp;&amp; nx2 &lt; width &amp;&amp; ny2 &gt;= 0 &amp;&amp; ny2 &lt; height) {&#10;&#9;&#9;&#9;&#9;&#9;Cv05_LinesDrawing.drawLine(vRam, nx1, ny1, nx2, ny2, color);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Omezení hodnoty na daný rozsah&#10;&#9; */&#10;&#9;private int clamp(int value, int min, int max) {&#10;&#9;&#9;return Math.max(min, Math.min(max, value));&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Vyčištění pozadí&#10;&#9; */&#10;&#9;private void clearBackground(V_RAM vRam, Color color) {&#10;&#9;&#9;for (int y = 0; y &lt; vRam.getHeight(); y++) {&#10;&#9;&#9;&#9;for (int x = 0; x &lt; vRam.getWidth(); x++) {&#10;&#9;&#9;&#9;&#9;vRam.setPixel(x, y, color.getRed(), color.getGreen(), color.getBlue());&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Zavření editoru při přerušení úlohy&#10;&#9; */&#10;&#9;public void dispose() {&#10;&#9;&#9;if (editorFrame != null) {&#10;&#9;&#9;&#9;SwingUtilities.invokeLater(() -&gt; {&#10;&#9;&#9;&#9;&#9;editorFrame.dispose();&#10;&#9;&#9;&#9;&#9;editorFrame = null;&#10;&#9;&#9;&#9;});&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package cz.osu.tasks;&#10;&#10;import cz.osu.exercises.Cv05_LinesDrawing;&#10;import cz.osu.main.MainWindow;&#10;import cz.osu.main.V_RAM;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.*;&#10;import java.io.*;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * KU2_EXT1 - Editor písmenového fontu pomocí Bézierových křivek&#10; *&#10; * Interaktivní editor pro tvorbu písmen pomocí kubických Bézierových křivek.&#10; * Umožňuje úpravu kontrolních bodů a vodítek (handles) myší a ukládání/načítání z JSON.&#10; */&#10;public class KU2_EXT1 {&#10;&#9;private final MainWindow mainWindow;&#10;&#9;private List&lt;CurvePoint&gt; controlPoints;&#10;&#9;private CurvePoint selectedPoint = null;&#10;&#9;private int selectedIndex = -1;&#10;&#9;private HandleType selectedHandle = HandleType.NONE;&#10;&#9;private static final int POINT_RADIUS = 6;&#10;&#9;private static final int HANDLE_RADIUS = 4;&#10;&#9;private static final String SAVE_FILE = &quot;letter_S_points.json&quot;;&#10;&#9;private static final int CANVAS_WIDTH = 600;&#10;&#9;private static final int CANVAS_HEIGHT = 600;&#10;&#9;private boolean showHandles = true;&#10;&#9;private JFrame editorFrame; // Reference na editor okno pro možnost zavření&#10;&#10;&#9;enum HandleType {&#10;&#9;&#9;NONE, MAIN, LEFT_HANDLE, RIGHT_HANDLE, BOTH_HANDLES&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Bod s vodítky pro Bézierovu křivku&#10;&#9; */&#10;&#9;class CurvePoint {&#10;&#9;&#9;Point main;        // Hlavní bod&#10;&#9;&#9;Point leftHandle;  // Levé vodítko (L)&#10;&#9;&#9;Point rightHandle; // Pravé vodítko (R)&#10;&#10;&#9;&#9;CurvePoint(int x, int y) {&#10;&#9;&#9;&#9;this.main = new Point(x, y);&#10;&#9;&#9;&#9;// Výchozí vodítka - automaticky vypočítaná&#10;&#9;&#9;&#9;this.leftHandle = new Point(x - 40, y);&#10;&#9;&#9;&#9;this.rightHandle = new Point(x + 40, y);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;CurvePoint(Point main, Point leftHandle, Point rightHandle) {&#10;&#9;&#9;&#9;this.main = main;&#10;&#9;&#9;&#9;this.leftHandle = leftHandle;&#10;&#9;&#9;&#9;this.rightHandle = rightHandle;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/**&#10;&#9;&#9; * Resetování handleru na výchozí pozici&#10;&#9;&#9; */&#10;&#9;&#9;void resetHandles() {&#10;&#9;&#9;&#9;this.leftHandle = new Point(main.x - 40, main.y);&#10;&#9;&#9;&#9;this.rightHandle = new Point(main.x + 40, main.y);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Automatický výpočet vodítek na základě sousedních bodů&#10;&#9;&#9;void autoCalculateHandles(CurvePoint prev, CurvePoint next) {&#10;&#9;&#9;&#9;if (prev == null || next == null) return;&#10;&#10;&#9;&#9;&#9;double dx = (next.main.x - prev.main.x) / 6.0;&#10;&#9;&#9;&#9;double dy = (next.main.y - prev.main.y) / 6.0;&#10;&#10;&#9;&#9;&#9;leftHandle = new Point(&#10;&#9;&#9;&#9;&#9;(int) Math.round(main.x - dx),&#10;&#9;&#9;&#9;&#9;(int) Math.round(main.y - dy)&#10;&#9;&#9;&#9;);&#10;&#9;&#9;&#9;rightHandle = new Point(&#10;&#9;&#9;&#9;&#9;(int) Math.round(main.x + dx),&#10;&#9;&#9;&#9;&#9;(int) Math.round(main.y + dy)&#10;&#9;&#9;&#9;);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;public KU2_EXT1(MainWindow mainWindow) {&#10;&#9;&#9;this.mainWindow = mainWindow;&#10;&#9;&#9;this.controlPoints = new ArrayList&lt;&gt;();&#10;&#9;&#9;loadPoints();&#10;&#9;}&#10;&#10;&#9;public void run() {&#10;&#9;&#9;System.out.println(&quot;KU2_EXT1.run() - START&quot;);&#10;&#9;&#9;&#10;&#9;&#9;// Pokud nejsou body, vytvoř výchozí&#10;&#9;&#9;if (controlPoints.isEmpty()) {&#10;&#9;&#9;&#9;createDefaultSPoints();&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Vytvoř editor okno&#10;&#9;&#9;createEditorWindow();&#10;&#9;&#9;&#10;&#9;&#9;// Čekej, dokud není thread přerušen&#10;&#9;&#9;// Editor běží v samostatném okně, ale tento thread musí zůstat živý&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;System.out.println(&quot;KU2_EXT1.run() - čekám na přerušení...&quot;);&#10;&#9;&#9;&#9;while (!Thread.currentThread().isInterrupted()) {&#10;&#9;&#9;&#9;&#9;Thread.sleep(100);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;} catch (InterruptedException e) {&#10;&#9;&#9;&#9;System.out.println(&quot;KU2_EXT1.run() - thread byl přerušen&quot;);&#10;&#9;&#9;&#9;Thread.currentThread().interrupt();&#10;&#9;&#9;} finally {&#10;&#9;&#9;&#9;System.out.println(&quot;KU2_EXT1.run() - END&quot;);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Vytvoření výchozích bodů pro písmeno S&#10;&#9; */&#10;&#9;private void createDefaultSPoints() {&#10;&#9;&#9;// Vytvoř body s pozicemi&#10;&#9;&#9;controlPoints.add(new CurvePoint(180, 80));&#10;&#10;&#9;&#9;// Automaticky vypočítej vodítka&#10;&#9;&#9;recalculateAllHandles();&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Přepočítání všech vodítek automaticky&#10;&#9; */&#10;&#9;private void recalculateAllHandles() {&#10;&#9;&#9;int n = controlPoints.size();&#10;&#9;&#9;if (n &lt; 2) return; // Potřebujeme alespoň 2 body&#10;&#10;&#9;&#9;if (n == 2) {&#10;&#9;&#9;&#9;// Pro 2 body vypočítej jednoduché vodítka&#10;&#9;&#9;&#9;CurvePoint p0 = controlPoints.get(0);&#10;&#9;&#9;&#9;CurvePoint p1 = controlPoints.get(1);&#10;&#10;&#9;&#9;&#9;double dx = (p1.main.x - p0.main.x) / 3.0;&#10;&#9;&#9;&#9;double dy = (p1.main.y - p0.main.y) / 3.0;&#10;&#10;&#9;&#9;&#9;p0.rightHandle = new Point(&#10;&#9;&#9;&#9;&#9;(int) Math.round(p0.main.x + dx),&#10;&#9;&#9;&#9;&#9;(int) Math.round(p0.main.y + dy)&#10;&#9;&#9;&#9;);&#10;&#9;&#9;&#9;p0.leftHandle = new Point(&#10;&#9;&#9;&#9;&#9;(int) Math.round(p0.main.x - dx),&#10;&#9;&#9;&#9;&#9;(int) Math.round(p0.main.y - dy)&#10;&#9;&#9;&#9;);&#10;&#10;&#9;&#9;&#9;p1.leftHandle = new Point(&#10;&#9;&#9;&#9;&#9;(int) Math.round(p1.main.x - dx),&#10;&#9;&#9;&#9;&#9;(int) Math.round(p1.main.y - dy)&#10;&#9;&#9;&#9;);&#10;&#9;&#9;&#9;p1.rightHandle = new Point(&#10;&#9;&#9;&#9;&#9;(int) Math.round(p1.main.x + dx),&#10;&#9;&#9;&#9;&#9;(int) Math.round(p1.main.y + dy)&#10;&#9;&#9;&#9;);&#10;&#9;&#9;&#9;return;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Pro 3+ bodů použij fantomové body&#10;&#9;&#9;List&lt;CurvePoint&gt; extended = new ArrayList&lt;&gt;();&#10;&#9;&#9;extended.add(controlPoints.get(0)); // Fantom na začátku&#10;&#9;&#9;extended.addAll(controlPoints);&#10;&#9;&#9;extended.add(controlPoints.get(n - 1)); // Fantom na konci&#10;&#10;&#9;&#9;// Vypočítej vodítka pro každý bod&#10;&#9;&#9;for (int i = 1; i &lt;= n; i++) {&#10;&#9;&#9;&#9;CurvePoint prev = extended.get(i - 1);&#10;&#9;&#9;&#9;CurvePoint curr = extended.get(i);&#10;&#9;&#9;&#9;CurvePoint next = extended.get(i + 1);&#10;&#10;&#9;&#9;&#9;curr.autoCalculateHandles(prev, next);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Načtení bodů z JSON souboru&#10;&#9; */&#10;&#9;private void loadPoints() {&#10;&#9;&#9;File file = new File(SAVE_FILE);&#10;&#9;&#9;if (!file.exists()) {&#10;&#9;&#9;&#9;return;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;try (BufferedReader reader = new BufferedReader(new FileReader(file))) {&#10;&#9;&#9;&#9;StringBuilder json = new StringBuilder();&#10;&#9;&#9;&#9;String line;&#10;&#9;&#9;&#9;while ((line = reader.readLine()) != null) {&#10;&#9;&#9;&#9;&#9;json.append(line.trim());&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;String content = json.toString();&#10;&#10;&#9;&#9;&#9;// Najdi začátek pole points&#10;&#9;&#9;&#9;int pointsStart = content.indexOf(&quot;[&quot;);&#10;&#9;&#9;&#9;int pointsEnd = content.lastIndexOf(&quot;]&quot;);&#10;&#10;&#9;&#9;&#9;if (pointsStart == -1 || pointsEnd == -1) {&#10;&#9;&#9;&#9;&#9;throw new Exception(&quot;Neplatný formát JSON&quot;);&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;String pointsArray = content.substring(pointsStart + 1, pointsEnd);&#10;&#9;&#9;&#9;controlPoints.clear();&#10;&#10;&#9;&#9;&#9;// Parsování jednotlivých objektů&#10;&#9;&#9;&#9;int depth = 0;&#10;&#9;&#9;&#9;StringBuilder currentObject = new StringBuilder();&#10;&#10;&#9;&#9;&#9;for (int i = 0; i &lt; pointsArray.length(); i++) {&#10;&#9;&#9;&#9;&#9;char c = pointsArray.charAt(i);&#10;&#10;&#9;&#9;&#9;&#9;if (c == '{') {&#10;&#9;&#9;&#9;&#9;&#9;depth++;&#10;&#9;&#9;&#9;&#9;&#9;currentObject.setLength(0);&#10;&#9;&#9;&#9;&#9;} else if (c == '}') {&#10;&#9;&#9;&#9;&#9;&#9;depth--;&#10;&#9;&#9;&#9;&#9;&#9;if (depth == 0 &amp;&amp; currentObject.length() &gt; 0) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;// Parsuj tento objekt&#10;&#9;&#9;&#9;&#9;&#9;&#9;parsePointObject(currentObject.toString());&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;} else if (depth &gt; 0) {&#10;&#9;&#9;&#9;&#9;&#9;currentObject.append(c);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;System.out.println(&quot;Načteno &quot; + controlPoints.size() + &quot; bodů z &quot; + SAVE_FILE);&#10;&#10;&#9;&#9;&#9;// Pokud body nemají vodítka, vypočítej je&#10;&#9;&#9;&#9;if (!controlPoints.isEmpty() &amp;&amp; controlPoints.get(0).leftHandle == null) {&#10;&#9;&#9;&#9;&#9;recalculateAllHandles();&#10;&#9;&#9;&#9;}&#10;&#9;&#9;} catch (Exception e) {&#10;&#9;&#9;&#9;System.out.println(&quot;Chyba při načítání: &quot; + e.getMessage());&#10;&#9;&#9;&#9;e.printStackTrace();&#10;&#9;&#9;&#9;controlPoints.clear();&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Parsování jednoho bodu z JSON objektu&#10;&#9; */&#10;&#9;private void parsePointObject(String objStr) {&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;Integer x = null, y = null;&#10;&#9;&#9;&#9;Integer lx = null, ly = null, rx = null, ry = null;&#10;&#10;&#9;&#9;&#9;// Rozděl na páry klíč:hodnota&#10;&#9;&#9;&#9;String[] pairs = objStr.split(&quot;,&quot;);&#10;&#10;&#9;&#9;&#9;for (String pair : pairs) {&#10;&#9;&#9;&#9;&#9;String[] kv = pair.split(&quot;:&quot;);&#10;&#9;&#9;&#9;&#9;if (kv.length != 2) continue;&#10;&#10;&#9;&#9;&#9;&#9;String key = kv[0].trim().replace(&quot;\&quot;&quot;, &quot;&quot;);&#10;&#9;&#9;&#9;&#9;String value = kv[1].trim();&#10;&#10;&#9;&#9;&#9;&#9;switch (key) {&#10;&#9;&#9;&#9;&#9;&#9;case &quot;x&quot;: x = Integer.parseInt(value); break;&#10;&#9;&#9;&#9;&#9;&#9;case &quot;y&quot;: y = Integer.parseInt(value); break;&#10;&#9;&#9;&#9;&#9;&#9;case &quot;lx&quot;: lx = Integer.parseInt(value); break;&#10;&#9;&#9;&#9;&#9;&#9;case &quot;ly&quot;: ly = Integer.parseInt(value); break;&#10;&#9;&#9;&#9;&#9;&#9;case &quot;rx&quot;: rx = Integer.parseInt(value); break;&#10;&#9;&#9;&#9;&#9;&#9;case &quot;ry&quot;: ry = Integer.parseInt(value); break;&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;if (x != null &amp;&amp; y != null) {&#10;&#9;&#9;&#9;&#9;if (lx != null &amp;&amp; ly != null &amp;&amp; rx != null &amp;&amp; ry != null) {&#10;&#9;&#9;&#9;&#9;&#9;// S vodítky&#10;&#9;&#9;&#9;&#9;&#9;controlPoints.add(new CurvePoint(&#10;&#9;&#9;&#9;&#9;&#9;&#9;new Point(x, y),&#10;&#9;&#9;&#9;&#9;&#9;&#9;new Point(lx, ly),&#10;&#9;&#9;&#9;&#9;&#9;&#9;new Point(rx, ry)&#10;&#9;&#9;&#9;&#9;&#9;));&#10;&#9;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;&#9;// Bez vodítek&#10;&#9;&#9;&#9;&#9;&#9;controlPoints.add(new CurvePoint(x, y));&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;} catch (Exception e) {&#10;&#9;&#9;&#9;System.out.println(&quot;Chyba při parsování bodu: &quot; + e.getMessage());&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Uložení bodů do JSON souboru&#10;&#9; */&#10;&#9;private void savePoints() {&#10;&#9;&#9;try (PrintWriter writer = new PrintWriter(new FileWriter(SAVE_FILE))) {&#10;&#9;&#9;&#9;writer.println(&quot;{&quot;);&#10;&#9;&#9;&#9;writer.println(&quot;  \&quot;points\&quot;: [&quot;);&#10;&#10;&#9;&#9;&#9;for (int i = 0; i &lt; controlPoints.size(); i++) {&#10;&#9;&#9;&#9;&#9;CurvePoint p = controlPoints.get(i);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;    {&quot;);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;\&quot;x\&quot;: &quot; + p.main.x + &quot;, &quot;);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;\&quot;y\&quot;: &quot; + p.main.y + &quot;, &quot;);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;\&quot;lx\&quot;: &quot; + p.leftHandle.x + &quot;, &quot;);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;\&quot;ly\&quot;: &quot; + p.leftHandle.y + &quot;, &quot;);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;\&quot;rx\&quot;: &quot; + p.rightHandle.x + &quot;, &quot;);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;\&quot;ry\&quot;: &quot; + p.rightHandle.y);&#10;&#9;&#9;&#9;&#9;writer.print(&quot;}&quot;);&#10;&#10;&#9;&#9;&#9;&#9;if (i &lt; controlPoints.size() - 1) {&#10;&#9;&#9;&#9;&#9;&#9;writer.println(&quot;,&quot;);&#10;&#9;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;&#9;writer.println();&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;writer.println(&quot;  ]&quot;);&#10;&#9;&#9;&#9;writer.println(&quot;}&quot;);&#10;&#10;&#9;&#9;&#9;System.out.println(&quot;Uloženo &quot; + controlPoints.size() + &quot; bodů do &quot; + SAVE_FILE);&#10;&#9;&#9;} catch (IOException e) {&#10;&#9;&#9;&#9;System.out.println(&quot;Chyba při ukládání: &quot; + e.getMessage());&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Vytvoření okna editoru&#10;&#9; */&#10;&#9;private void createEditorWindow() {&#10;&#9;&#9;editorFrame = new JFrame(&quot;Editor písmene S - Bézierovy křivky (Ctrl+klik = oba handlers)&quot;);&#10;&#9;&#9;editorFrame.setSize(700, 800);&#10;&#9;&#9;editorFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);&#10;&#9;&#9;editorFrame.setResizable(true); // Povolení změny velikosti&#10;&#10;&#9;&#9;// Panel pro kreslení s ohraničením&#10;&#9;&#9;JPanel drawPanel = new JPanel() {&#10;&#9;&#9;&#9;@Override&#10;&#9;&#9;&#9;public Dimension getPreferredSize() {&#10;&#9;&#9;&#9;&#9;return new Dimension(CANVAS_WIDTH + 100, CANVAS_HEIGHT + 100);&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;@Override&#10;&#9;&#9;&#9;protected void paintComponent(Graphics g) {&#10;&#9;&#9;&#9;&#9;super.paintComponent(g);&#10;&#9;&#9;&#9;&#9;Graphics2D g2d = (Graphics2D) g;&#10;&#9;&#9;&#9;&#9;g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;&#10;&#9;&#9;&#9;&#9;// Vyčištění pozadí (světle šedé)&#10;&#9;&#9;&#9;&#9;g2d.setColor(new Color(240, 240, 240));&#10;&#9;&#9;&#9;&#9;g2d.fillRect(0, 0, getWidth(), getHeight());&#10;&#10;&#9;&#9;&#9;&#9;// Vykreslení plátna (bílé)&#10;&#9;&#9;&#9;&#9;int offsetX = (getWidth() - CANVAS_WIDTH) / 2;&#10;&#9;&#9;&#9;&#9;int offsetY = (getHeight() - CANVAS_HEIGHT) / 2;&#10;&#9;&#9;&#9;&#9;g2d.setColor(Color.WHITE);&#10;&#9;&#9;&#9;&#9;g2d.fillRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);&#10;&#10;&#9;&#9;&#9;&#9;// Ohraničení plátna&#10;&#9;&#9;&#9;&#9;g2d.setColor(Color.BLACK);&#10;&#9;&#9;&#9;&#9;g2d.setStroke(new BasicStroke(2));&#10;&#9;&#9;&#9;&#9;g2d.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);&#10;&#10;&#9;&#9;&#9;&#9;// Translace pro vycentrování&#10;&#9;&#9;&#9;&#9;g2d.translate(offsetX, offsetY);&#10;&#10;&#9;&#9;&#9;&#9;if (controlPoints.size() &gt;= 2) {&#10;&#9;&#9;&#9;&#9;&#9;// Vykreslení spline&#10;&#9;&#9;&#9;&#9;&#9;drawSplineOnGraphics(g2d, controlPoints, Color.BLACK);&#10;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;// Vykreslení vodítek a kontrolních bodů&#10;&#9;&#9;&#9;&#9;for (int i = 0; i &lt; controlPoints.size(); i++) {&#10;&#9;&#9;&#9;&#9;&#9;CurvePoint p = controlPoints.get(i);&#10;&#10;&#9;&#9;&#9;&#9;&#9;if (showHandles) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;// Vodítka - čáry&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.setColor(new Color(150, 150, 255));&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.setStroke(new BasicStroke(1));&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.drawLine(p.main.x, p.main.y, p.leftHandle.x, p.leftHandle.y);&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.drawLine(p.main.x, p.main.y, p.rightHandle.x, p.rightHandle.y);&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// Levé vodítko&#10;&#9;&#9;&#9;&#9;&#9;&#9;boolean isSelectedLeft = (i == selectedIndex &amp;&amp; selectedHandle == HandleType.LEFT_HANDLE);&#10;&#9;&#9;&#9;&#9;&#9;&#9;boolean isBothSelected = (i == selectedIndex &amp;&amp; selectedHandle == HandleType.BOTH_HANDLES);&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.setColor((isSelectedLeft || isBothSelected) ? Color.RED : new Color(100, 100, 255));&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.fillOval(p.leftHandle.x - HANDLE_RADIUS, p.leftHandle.y - HANDLE_RADIUS,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;HANDLE_RADIUS * 2, HANDLE_RADIUS * 2);&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// Pravé vodítko&#10;&#9;&#9;&#9;&#9;&#9;&#9;boolean isSelectedRight = (i == selectedIndex &amp;&amp; selectedHandle == HandleType.RIGHT_HANDLE);&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.setColor((isSelectedRight || isBothSelected) ? Color.RED : new Color(100, 100, 255));&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.fillOval(p.rightHandle.x - HANDLE_RADIUS, p.rightHandle.y - HANDLE_RADIUS,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;HANDLE_RADIUS * 2, HANDLE_RADIUS * 2);&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;// Spojnice mezi hlavními body&#10;&#9;&#9;&#9;&#9;&#9;if (i &gt; 0) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.setColor(new Color(200, 200, 200));&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{2}, 0));&#10;&#9;&#9;&#9;&#9;&#9;&#9;CurvePoint prev = controlPoints.get(i - 1);&#10;&#9;&#9;&#9;&#9;&#9;&#9;g2d.drawLine(prev.main.x, prev.main.y, p.main.x, p.main.y);&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;// Hlavní bod&#10;&#9;&#9;&#9;&#9;&#9;boolean isSelectedMain = (i == selectedIndex &amp;&amp;&#10;&#9;&#9;&#9;&#9;&#9;&#9;(selectedHandle == HandleType.MAIN || selectedHandle == HandleType.BOTH_HANDLES));&#10;&#9;&#9;&#9;&#9;&#9;g2d.setColor(isSelectedMain ? Color.RED : Color.BLUE);&#10;&#9;&#9;&#9;&#9;&#9;g2d.fillOval(p.main.x - POINT_RADIUS, p.main.y - POINT_RADIUS,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;POINT_RADIUS * 2, POINT_RADIUS * 2);&#10;&#10;&#9;&#9;&#9;&#9;&#9;// Číslo bodu&#10;&#9;&#9;&#9;&#9;&#9;g2d.setColor(Color.BLACK);&#10;&#9;&#9;&#9;&#9;&#9;g2d.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 10));&#10;&#9;&#9;&#9;&#9;&#9;g2d.drawString(String.valueOf(i), p.main.x + POINT_RADIUS + 2, p.main.y - POINT_RADIUS);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;};&#10;&#10;&#9;&#9;drawPanel.setBackground(Color.WHITE);&#10;&#10;&#9;&#9;// Mouse listener pro editaci bodů&#10;&#9;&#9;MouseAdapter mouseAdapter = new MouseAdapter() {&#10;&#9;&#9;&#9;private int getOffsetX() {&#10;&#9;&#9;&#9;&#9;return (drawPanel.getWidth() - CANVAS_WIDTH) / 2;&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;private int getOffsetY() {&#10;&#9;&#9;&#9;&#9;return (drawPanel.getHeight() - CANVAS_HEIGHT) / 2;&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;private int toCanvasX(int mouseX) {&#10;&#9;&#9;&#9;&#9;return mouseX - getOffsetX();&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;private int toCanvasY(int mouseY) {&#10;&#9;&#9;&#9;&#9;return mouseY - getOffsetY();&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;@Override&#10;&#9;&#9;&#9;public void mousePressed(MouseEvent e) {&#10;&#9;&#9;&#9;&#9;int canvasX = toCanvasX(e.getX());&#10;&#9;&#9;&#9;&#9;int canvasY = toCanvasY(e.getY());&#10;&#9;&#9;&#9;&#9;boolean ctrlPressed = e.isControlDown();&#10;&#10;&#9;&#9;&#9;&#9;// Nejprve hledej vodítka, pak hlavní body&#10;&#9;&#9;&#9;&#9;for (int i = 0; i &lt; controlPoints.size(); i++) {&#10;&#9;&#9;&#9;&#9;&#9;CurvePoint p = controlPoints.get(i);&#10;&#10;&#9;&#9;&#9;&#9;&#9;if (showHandles) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;// Levé vodítko&#10;&#9;&#9;&#9;&#9;&#9;&#9;if (isNear(canvasX, canvasY, p.leftHandle.x, p.leftHandle.y, HANDLE_RADIUS)) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint = p;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedIndex = i;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedHandle = HandleType.LEFT_HANDLE;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;return;&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// Pravé vodítko&#10;&#9;&#9;&#9;&#9;&#9;&#9;if (isNear(canvasX, canvasY, p.rightHandle.x, p.rightHandle.y, HANDLE_RADIUS)) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint = p;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedIndex = i;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedHandle = HandleType.RIGHT_HANDLE;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;return;&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;// Hlavní bod - s Ctrl = oba handlers, bez Ctrl = jen bod&#10;&#9;&#9;&#9;&#9;&#9;if (isNear(canvasX, canvasY, p.main.x, p.main.y, POINT_RADIUS)) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint = p;&#10;&#9;&#9;&#9;&#9;&#9;&#9;selectedIndex = i;&#10;&#9;&#9;&#9;&#9;&#9;&#9;selectedHandle = ctrlPressed ? HandleType.BOTH_HANDLES : HandleType.MAIN;&#10;&#9;&#9;&#9;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;&#9;&#9;&#9;return;&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;selectedPoint = null;&#10;&#9;&#9;&#9;&#9;selectedIndex = -1;&#10;&#9;&#9;&#9;&#9;selectedHandle = HandleType.NONE;&#10;&#9;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;@Override&#10;&#9;&#9;&#9;public void mouseDragged(MouseEvent e) {&#10;&#9;&#9;&#9;&#9;if (selectedPoint != null) {&#10;&#9;&#9;&#9;&#9;&#9;int canvasX = toCanvasX(e.getX());&#10;&#9;&#9;&#9;&#9;&#9;int canvasY = toCanvasY(e.getY());&#10;&#9;&#9;&#9;&#9;&#9;int clampedX = clamp(canvasX, 0, CANVAS_WIDTH - 1);&#10;&#9;&#9;&#9;&#9;&#9;int clampedY = clamp(canvasY, 0, CANVAS_HEIGHT - 1);&#10;&#10;&#9;&#9;&#9;&#9;&#9;switch (selectedHandle) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;case MAIN:&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Posuň hlavní bod i vodítka&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int dx = clampedX - selectedPoint.main.x;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int dy = clampedY - selectedPoint.main.y;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.main.x = clampedX;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.main.y = clampedY;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.leftHandle.x = clamp(selectedPoint.leftHandle.x + dx, 0, CANVAS_WIDTH - 1);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.leftHandle.y = clamp(selectedPoint.leftHandle.y + dy, 0, CANVAS_HEIGHT - 1);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.rightHandle.x = clamp(selectedPoint.rightHandle.x + dx, 0, CANVAS_WIDTH - 1);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.rightHandle.y = clamp(selectedPoint.rightHandle.y + dy, 0, CANVAS_HEIGHT - 1);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;&#9;&#9;case LEFT_HANDLE:&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.leftHandle.x = clampedX;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.leftHandle.y = clampedY;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;&#9;&#9;case RIGHT_HANDLE:&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.rightHandle.x = clampedX;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.rightHandle.y = clampedY;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;&#9;&#9;case BOTH_HANDLES:&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Symetrický pohyb obou handlers - myš ovládá směr&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int deltaX = clampedX - selectedPoint.main.x;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;int deltaY = clampedY - selectedPoint.main.y;&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Pravý handle jde tam, kam je myš&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.rightHandle.x = clampedX;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.rightHandle.y = clampedY;&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// Levý handle jde na opačnou stranu symetricky&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.leftHandle.x = clamp(selectedPoint.main.x - deltaX, 0, CANVAS_WIDTH - 1);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;selectedPoint.leftHandle.y = clamp(selectedPoint.main.y - deltaY, 0, CANVAS_HEIGHT - 1);&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;@Override&#10;&#9;&#9;&#9;public void mouseReleased(MouseEvent e) {&#10;&#9;&#9;&#9;&#9;if (selectedPoint != null) {&#10;&#9;&#9;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;private boolean isNear(int x1, int y1, int x2, int y2, int radius) {&#10;&#9;&#9;&#9;&#9;return Math.abs(x1 - x2) &lt;= radius &amp;&amp; Math.abs(y1 - y2) &lt;= radius;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;};&#10;&#10;&#9;&#9;drawPanel.addMouseListener(mouseAdapter);&#10;&#9;&#9;drawPanel.addMouseMotionListener(mouseAdapter);&#10;&#10;&#9;&#9;// Panel s tlačítky&#10;&#9;&#9;JPanel buttonPanel = new JPanel();&#10;&#9;&#9;buttonPanel.setLayout(new GridLayout(3, 2, 5, 5));&#10;&#10;&#9;&#9;JButton saveButton = new JButton(&quot;Uložit&quot;);&#10;&#9;&#9;saveButton.addActionListener(e -&gt; {&#10;&#9;&#9;&#9;savePoints();&#10;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;});&#10;&#10;&#9;&#9;JButton loadButton = new JButton(&quot;Načíst&quot;);&#10;&#9;&#9;loadButton.addActionListener(e -&gt; {&#10;&#9;&#9;&#9;loadPoints();&#10;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;});&#10;&#10;&#9;&#9;JButton addButton = new JButton(&quot;Přidat bod&quot;);&#10;&#9;&#9;addButton.addActionListener(e -&gt; {&#10;&#9;&#9;&#9;// Přidat nový bod bez přepočítávání existujících handlers&#10;&#9;&#9;&#9;controlPoints.add(new CurvePoint(150, 150));&#10;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;});&#10;&#10;&#9;&#9;JButton removeButton = new JButton(&quot;Odebrat bod&quot;);&#10;&#9;&#9;removeButton.addActionListener(e -&gt; {&#10;&#9;&#9;&#9;if (selectedIndex &gt;= 0 &amp;&amp; selectedIndex &lt; controlPoints.size()) {&#10;&#9;&#9;&#9;&#9;controlPoints.remove(selectedIndex);&#10;&#9;&#9;&#9;&#9;selectedIndex = -1;&#10;&#9;&#9;&#9;&#9;selectedPoint = null;&#10;&#9;&#9;&#9;&#9;selectedHandle = HandleType.NONE;&#10;&#9;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;&#9;}&#10;&#9;&#9;});&#10;&#10;&#9;&#9;JButton resetButton = new JButton(&quot;Reset&quot;);&#10;&#9;&#9;resetButton.addActionListener(e -&gt; {&#10;&#9;&#9;&#9;controlPoints.clear();&#10;&#9;&#9;&#9;createDefaultSPoints();&#10;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;});&#10;&#10;&#9;&#9;JButton toggleHandlesButton = new JButton(&quot;Vodítka: ZAP&quot;);&#10;&#9;&#9;toggleHandlesButton.addActionListener(e -&gt; {&#10;&#9;&#9;&#9;showHandles = !showHandles;&#10;&#9;&#9;&#9;toggleHandlesButton.setText(&quot;Vodítka: &quot; + (showHandles ? &quot;ZAP&quot; : &quot;VYP&quot;));&#10;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;});&#10;&#10;&#9;&#9;JButton resetHandlesButton = new JButton(&quot;Reset vodítka&quot;);&#10;&#9;&#9;resetHandlesButton.addActionListener(e -&gt; {&#10;&#9;&#9;&#9;if (selectedIndex &gt;= 0 &amp;&amp; selectedIndex &lt; controlPoints.size()) {&#10;&#9;&#9;&#9;&#9;controlPoints.get(selectedIndex).resetHandles();&#10;&#9;&#9;&#9;&#9;drawPanel.repaint();&#10;&#9;&#9;&#9;&#9;updateMainWindow();&#10;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;JOptionPane.showMessageDialog(editorFrame,&#10;&#9;&#9;&#9;&#9;&#9;&quot;Nejdřív vyberte bod kliknutím na něj.&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&quot;Info&quot;,&#10;&#9;&#9;&#9;&#9;&#9;JOptionPane.INFORMATION_MESSAGE);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;});&#10;&#10;&#9;&#9;buttonPanel.add(saveButton);&#10;&#9;&#9;buttonPanel.add(loadButton);&#10;&#9;&#9;buttonPanel.add(addButton);&#10;&#9;&#9;buttonPanel.add(removeButton);&#10;&#9;&#9;buttonPanel.add(resetButton);&#10;&#9;&#9;buttonPanel.add(toggleHandlesButton);&#10;&#9;&#9;buttonPanel.add(resetHandlesButton);&#10;&#10;&#9;&#9;// Sestavení okna&#10;&#9;&#9;editorFrame.setLayout(new BorderLayout());&#10;&#9;&#9;editorFrame.add(drawPanel, BorderLayout.CENTER);&#10;&#9;&#9;editorFrame.add(buttonPanel, BorderLayout.SOUTH);&#10;&#10;&#9;&#9;editorFrame.setVisible(true);&#10;&#10;&#9;&#9;// Počáteční vykreslení&#10;&#9;&#9;updateMainWindow();&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Aktualizace hlavního okna s výsledným písmem&#10;&#9; */&#10;&#9;private void updateMainWindow() {&#10;&#9;&#9;V_RAM vRam = new V_RAM(CANVAS_WIDTH, CANVAS_HEIGHT);&#10;&#9;&#9;clearBackground(vRam, Color.WHITE);&#10;&#10;&#9;&#9;if (controlPoints.size() &gt;= 2) {&#10;&#9;&#9;&#9;drawSplineVRAM(vRam, controlPoints, Color.BLACK, 2);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;mainWindow.showImage(vRam.getImage());&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Vykreslení spline na Graphics2D (pro editor)&#10;&#9; */&#10;&#9;private void drawSplineOnGraphics(Graphics2D g2d, List&lt;CurvePoint&gt; points, Color color) {&#10;&#9;&#9;int n = points.size();&#10;&#9;&#9;if (n &lt; 2) return;&#10;&#10;&#9;&#9;g2d.setColor(color);&#10;&#9;&#9;g2d.setStroke(new BasicStroke(2));&#10;&#10;&#9;&#9;// Definice a vykreslení segmentů&#10;&#9;&#9;double step = 0.01;&#10;&#10;&#9;&#9;for (int i = 0; i &lt; n - 1; i++) {&#10;&#9;&#9;&#9;CurvePoint p0 = points.get(i);&#10;&#9;&#9;&#9;CurvePoint p1 = points.get(i + 1);&#10;&#10;&#9;&#9;&#9;// 4 kontrolní body pro kubickou Bézierovu křivku&#10;&#9;&#9;&#9;Point cp0 = p0.main;           // Začátek&#10;&#9;&#9;&#9;Point cp1 = p0.rightHandle;    // Pravé vodítko prvního bodu&#10;&#9;&#9;&#9;Point cp2 = p1.leftHandle;     // Levé vodítko druhého bodu&#10;&#9;&#9;&#9;Point cp3 = p1.main;           // Konec&#10;&#10;&#9;&#9;&#9;// Pre-kalkulace koeficientů&#10;&#9;&#9;&#9;double qx0 = cp0.x;&#10;&#9;&#9;&#9;double qy0 = cp0.y;&#10;&#9;&#9;&#9;double qx1 = 3 * (cp1.x - cp0.x);&#10;&#9;&#9;&#9;double qy1 = 3 * (cp1.y - cp0.y);&#10;&#9;&#9;&#9;double qx2 = 3 * (cp0.x - 2 * cp1.x + cp2.x);&#10;&#9;&#9;&#9;double qy2 = 3 * (cp0.y - 2 * cp1.y + cp2.y);&#10;&#9;&#9;&#9;double qx3 = cp3.x - 3 * cp2.x + 3 * cp1.x - cp0.x;&#10;&#9;&#9;&#9;double qy3 = cp3.y - 3 * cp2.y + 3 * cp1.y - cp0.y;&#10;&#10;&#9;&#9;&#9;Point prevPoint = null;&#10;&#10;&#9;&#9;&#9;for (double t = 0.0; t &lt;= 1.0; t += step) {&#10;&#9;&#9;&#9;&#9;double t2 = t * t;&#10;&#9;&#9;&#9;&#9;double t3 = t2 * t;&#10;&#10;&#9;&#9;&#9;&#9;double x = qx0 + qx1 * t + qx2 * t2 + qx3 * t3;&#10;&#9;&#9;&#9;&#9;double y = qy0 + qy1 * t + qy2 * t2 + qy3 * t3;&#10;&#10;&#9;&#9;&#9;&#9;Point currentPoint = new Point((int) Math.round(x), (int) Math.round(y));&#10;&#10;&#9;&#9;&#9;&#9;if (prevPoint != null) {&#10;&#9;&#9;&#9;&#9;&#9;g2d.drawLine(prevPoint.x, prevPoint.y, currentPoint.x, currentPoint.y);&#10;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;prevPoint = currentPoint;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Vykreslení spline do V_RAM&#10;&#9; */&#10;&#9;private void drawSplineVRAM(V_RAM vRam, List&lt;CurvePoint&gt; points, Color color, int thickness) {&#10;&#9;&#9;int n = points.size();&#10;&#9;&#9;if (n &lt; 2) return;&#10;&#10;&#9;&#9;int width = vRam.getWidth();&#10;&#9;&#9;int height = vRam.getHeight();&#10;&#10;&#9;&#9;// Definice a vykreslení segmentů&#10;&#9;&#9;double step = 0.005;&#10;&#10;&#9;&#9;for (int i = 0; i &lt; n - 1; i++) {&#10;&#9;&#9;&#9;CurvePoint p0 = points.get(i);&#10;&#9;&#9;&#9;CurvePoint p1 = points.get(i + 1);&#10;&#10;&#9;&#9;&#9;// 4 kontrolní body&#10;&#9;&#9;&#9;Point cp0 = p0.main;&#10;&#9;&#9;&#9;Point cp1 = p0.rightHandle;&#10;&#9;&#9;&#9;Point cp2 = p1.leftHandle;&#10;&#9;&#9;&#9;Point cp3 = p1.main;&#10;&#10;&#9;&#9;&#9;// Pre-kalkulace koeficientů&#10;&#9;&#9;&#9;double qx0 = cp0.x;&#10;&#9;&#9;&#9;double qy0 = cp0.y;&#10;&#9;&#9;&#9;double qx1 = 3 * (cp1.x - cp0.x);&#10;&#9;&#9;&#9;double qy1 = 3 * (cp1.y - cp0.y);&#10;&#9;&#9;&#9;double qx2 = 3 * (cp0.x - 2 * cp1.x + cp2.x);&#10;&#9;&#9;&#9;double qy2 = 3 * (cp0.y - 2 * cp1.y + cp2.y);&#10;&#9;&#9;&#9;double qx3 = cp3.x - 3 * cp2.x + 3 * cp1.x - cp0.x;&#10;&#9;&#9;&#9;double qy3 = cp3.y - 3 * cp2.y + 3 * cp1.y - cp0.y;&#10;&#10;&#9;&#9;&#9;Point prevPoint = null;&#10;&#10;&#9;&#9;&#9;for (double t = 0.0; t &lt;= 1.0; t += step) {&#10;&#9;&#9;&#9;&#9;double t2 = t * t;&#10;&#9;&#9;&#9;&#9;double t3 = t2 * t;&#10;&#10;&#9;&#9;&#9;&#9;double x = qx0 + qx1 * t + qx2 * t2 + qx3 * t3;&#10;&#9;&#9;&#9;&#9;double y = qy0 + qy1 * t + qy2 * t2 + qy3 * t3;&#10;&#10;&#9;&#9;&#9;&#9;// Bounds checking&#10;&#9;&#9;&#9;&#9;int px = (int) Math.round(x);&#10;&#9;&#9;&#9;&#9;int py = (int) Math.round(y);&#10;&#9;&#9;&#9;&#9;if (px &lt; 0 || px &gt;= width || py &lt; 0 || py &gt;= height) {&#10;&#9;&#9;&#9;&#9;&#9;prevPoint = null; // Přeskoč kreslení mimo hranice&#10;&#9;&#9;&#9;&#9;&#9;continue;&#10;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;Point currentPoint = new Point(px, py);&#10;&#10;&#9;&#9;&#9;&#9;if (prevPoint != null) {&#10;&#9;&#9;&#9;&#9;&#9;drawThickLine(vRam, prevPoint.x, prevPoint.y, currentPoint.x, currentPoint.y, color, thickness);&#10;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;prevPoint = currentPoint;&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;// Závěrečný segment&#10;&#9;&#9;&#9;int fx = (int) Math.round(qx0 + qx1 + qx2 + qx3);&#10;&#9;&#9;&#9;int fy = (int) Math.round(qy0 + qy1 + qy2 + qy3);&#10;&#10;&#9;&#9;&#9;if (fx &gt;= 0 &amp;&amp; fx &lt; width &amp;&amp; fy &gt;= 0 &amp;&amp; fy &lt; height) {&#10;&#9;&#9;&#9;&#9;Point finalPoint = new Point(fx, fy);&#10;&#9;&#9;&#9;&#9;if (prevPoint != null) {&#10;&#9;&#9;&#9;&#9;&#9;drawThickLine(vRam, prevPoint.x, prevPoint.y, finalPoint.x, finalPoint.y, color, thickness);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Kreslení tlustší čáry&#10;&#9; */&#10;&#9;private void drawThickLine(V_RAM vRam, int x1, int y1, int x2, int y2, Color color, int thickness) {&#10;&#9;&#9;int width = vRam.getWidth();&#10;&#9;&#9;int height = vRam.getHeight();&#10;&#10;&#9;&#9;for (int dy = -thickness/2; dy &lt;= thickness/2; dy++) {&#10;&#9;&#9;&#9;for (int dx = -thickness/2; dx &lt;= thickness/2; dx++) {&#10;&#9;&#9;&#9;&#9;int nx1 = x1 + dx;&#10;&#9;&#9;&#9;&#9;int ny1 = y1 + dy;&#10;&#9;&#9;&#9;&#9;int nx2 = x2 + dx;&#10;&#9;&#9;&#9;&#9;int ny2 = y2 + dy;&#10;&#10;&#9;&#9;&#9;&#9;// Bounds checking - kreslí jen pokud jsou OBA body v rozsahu&#10;&#9;&#9;&#9;&#9;if (nx1 &gt;= 0 &amp;&amp; nx1 &lt; width &amp;&amp; ny1 &gt;= 0 &amp;&amp; ny1 &lt; height &amp;&amp;&#10;&#9;&#9;&#9;&#9;&#9;nx2 &gt;= 0 &amp;&amp; nx2 &lt; width &amp;&amp; ny2 &gt;= 0 &amp;&amp; ny2 &lt; height) {&#10;&#9;&#9;&#9;&#9;&#9;Cv05_LinesDrawing.drawLine(vRam, nx1, ny1, nx2, ny2, color);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Omezení hodnoty na daný rozsah&#10;&#9; */&#10;&#9;private int clamp(int value, int min, int max) {&#10;&#9;&#9;return Math.max(min, Math.min(max, value));&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Vyčištění pozadí&#10;&#9; */&#10;&#9;private void clearBackground(V_RAM vRam, Color color) {&#10;&#9;&#9;for (int y = 0; y &lt; vRam.getHeight(); y++) {&#10;&#9;&#9;&#9;for (int x = 0; x &lt; vRam.getWidth(); x++) {&#10;&#9;&#9;&#9;&#9;vRam.setPixel(x, y, color.getRed(), color.getGreen(), color.getBlue());&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Zavření editoru při přerušení úlohy&#10;&#9; */&#10;&#9;public void dispose() {&#10;&#9;&#9;System.out.println(&quot;KU2_EXT1.dispose() - zavírám editor&quot;);&#10;&#9;&#9;if (editorFrame != null) {&#10;&#9;&#9;&#9;SwingUtilities.invokeLater(() -&gt; {&#10;&#9;&#9;&#9;&#9;System.out.println(&quot;KU2_EXT1.dispose() - volám editorFrame.dispose()&quot;);&#10;&#9;&#9;&#9;&#9;editorFrame.dispose();&#10;&#9;&#9;&#9;&#9;editorFrame = null;&#10;&#9;&#9;&#9;});&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;System.out.println(&quot;KU2_EXT1.dispose() - editorFrame je null&quot;);&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>